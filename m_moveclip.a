
	!src "..\godotlib.lib"
	*= $c000
	!ct pet

; --------------------------------------
;
;     mod.MoveClip
;       Modifier zum Kopieren, Verschieben oder Tauschen von Clips
;       innerhalb des 4Bit-Bildes
;     von Martin Burggraf (1.01: $AD)
;
;     1.00, 04.10.95, first release (still buggy)
;     1.01, 08.01.18, re-coded for convenience, bugfixes
;                     first fully functional version
;     1.02, 09.01.18, no need to input again and again anymore
;     1.03, 13.01.18, added: visually set position of destination
;                     added: take over new clip position (or not)
;
; --------------------------------------
;
;      Repaired:
;      Changed zeropage addresses to an area which does not affect
;      any C64 functionality (to $30++); coded a new positioning
;      routine which would deliver correct results; minor bugfixing.
;
; -------------------------------------- 


; -------------------------------------- Equates

	pport		= $01
	merk		= $07
	int		= $14
	wordlo		= $15

	save		= $30
	zl		= $31
	sp		= $32
	zlmk		= $33
	spmk		= $34
	zwisp		= $35	; /$36
	source		= $37	; /$38
	destin		= $39	; /$3a
	flag		= $3b
	flag2		= $3c
	colo		= $3d
	quellzeile	= $3e
	quellspalte	= $3f
	dispmk		= $40
	zaehlersp		= $42
	zaehlerzl		= $43

	togg		= $44
	slot		= $45
	v1buf		= $47
	v2buf		= $48
	cbuf		= $49

	vram2		= $ce0b
	vram1		= $de0b
	cstart		= $ee0b

	grafreg		= $d011
	multreg		= $d016
	charreg		= $d018
	rahmen		= $d020
	backgr		= $d021

; -------------------------------------- Header

	jmp start

	!by $20,$00,$01 
	!wo modend
	!wo 0
	!tx "Move the Clip ! "
	!tx "1.03"
	!tx "13.01.18"
	!tx "M.Burggraf/$AD  "

; -------------------------------------- Main

start	ldx sc_screenvek	; save vector to mainlist
	stx list
	ldx sc_screenvek+1
	stx list+1
	lda gd_modswitch
	sta save
	lda gr_redisp	; save flag for re-render
	sta dispmk

	jsr init
	jsr checkcols	; where is which module? (for re-display)
	ldx #<liste
	ldy #>liste
	jsr gd_screen
	jsr gd_eloop

	lda save
	sta gd_modswitch

; -------------------------------------- Event: Exit

cancel	lda dispmk
	sta gr_redisp
	sec 
	rts 

; -------------------------------------- Event: Copy

befcopy	lda #2
	sta flag2
	bne cliptrans

; -------------------------------------- Event: Move

befmove	lda #1
	sta flag2
	bne cliptrans

; -------------------------------------- Event: Exchange

befchang	lda #0
	sta flag2

; -------------------------------------- Perform Transport

cliptrans	jsr initad

	lda #$ff		; Höhenzähler vor 0 setzen
	sta zaehlerzl
	sta dispmk

lp1	lda #0		; Spaltenzähler auf Start (0)
	sta zaehlersp
	jsr countad	; Move activity bar
	jsr countad
	inc zaehlerzl	; Höhe abzählen
	lda zaehlerzl	; height complete?
	cmp zhoehe
	bcc lp0		; no, transport

	lda transfl
	beq +
	ldx zzeile
	ldy zspalte
	stx sc_lastclpzl
	sty sc_lastclpsp
	jsr reinit
+	jsr clearad	; finished
	sec 
	rts

; -------------------------------------- 

lp0	jsr blocktrans	; no, transport
	inc zaehlersp
	lda zaehlersp	; width complete?
	cmp zbreite
	bcc lp0
	bcs lp1

; -------------------------------------- Transport one 4Bit-Tile

blocktrans
	jsr calcblock	; calculate source and target addresses

	sei 
	lda pport
	pha 
	lda #1
	sta pport
	ldy #31		; transport 32 bytes (1 tile)
-	jsr transsub
	dey 
	bpl -
	pla 
	sta pport
	cli 

	rts 

; -------------------------------------- Calculate Addresses

calcblock	clc
	lda quellzeile	; neue Zeile
	adc zaehlerzl
	sta zl
	lda quellspalte	; neue Spalte
	adc zaehlersp
	sta sp
	lda #0		; first: source
	sta flag
	jsr clcblksub	; perform calculation

	clc		; then: destination
	lda zzeile
	adc zaehlerzl
	sta zl
	lda zspalte
	adc zaehlersp
	sta sp
	inc flag

; -------------------------------------- Perform Calculation

clcblksub	lda #$40		; rows from start of 4Bit ($4000+zl*$500)
	sta zwisp+1
	ldx zl
	beq ++

-	clc
	adc #$05
	dec zl
	bne -
	sta zwisp+1

++	lda sp
	beq ++

	lda #0		; columns row+sp*32
-	clc
	adc #32
	bcc +
	inc zwisp+1
+	dec sp
	bne -

++	ldx zwisp+1	; Hi addr (lo in .a)
	ldy flag
	bne +
	stx source+1	; set source
	sta source
	rts

+	stx destin+1	; set destination
	sta destin
	rts 

; -------------------------------------- Distributor

transsub	ldx flag2
	beq change
	dex 
	beq move

; -------------------------------------- Perform Copy

copy	lda (source),y	; just source to destination
	sta (destin),y
	rts 

; -------------------------------------- Perform Move

move	lda (source),y	; source to destination, then
	sta (destin),y
	lda colo		; fill source
	sta (source),y
	rts

; -------------------------------------- Perform Exchange

change	lda (source),y	; save source
	pha 
	lda (destin),y	; destination to source
	sta (source),y
	pla 
	sta (destin),y	; re-get source and set destination
-	clc
	rts 

; -------------------------------------- Event: Set Flag for TakeOver

sevtkover	ldx transfl
	beq +
	ldx #$ff
+	inx
	stx transfl
	beq +
	ldx #6
+	ldy #5
-	lda transtx,x
	sta togtx,y
	inx
	dey
	bpl -
	ldy #4
	bne out2

; -------------------------------------- Event: Input Row of Target

row	jsr ss16		; Input
	beq -
chrow	sta zzeile
	clc
	adc zhoehe
	cmp #26
	bcc +
	jsr ss14
	lda zlmk
	sta zzeile

+	lda zzeile
	sta zlmk
	jsr getzif	; convert to digits
	stx zzltx		; in Screenlist schreiben
	sta zzltx+1
	ldy #0
	beq out2

; -------------------------------------- Event: Input Column of Target

col	jsr ss16		; Input
	beq -
chcol	sta zspalte
	clc
	adc zbreite
	cmp #41
	bcc +
	jsr ss14
	lda spmk
	sta zspalte

+	lda zspalte
	sta spmk
	jsr getzif	; convert to digits
	stx zsptx		; in Screenlist schreiben
	sta zsptx+1
	ldy #2

out2	jsr settab
	jsr gettab
	ldy #6		; and display
	jmp gd_xtxout1

; ------------------------------------------------ Event: SetClip

sevsetcl	ldx #0		; clear key buffer
	stx sy_tbuffer
	sta sc_stop
	inx
	stx gr_redisp
	jsr redisplay	; turn graphics on
	lda quellzeile	; set clip values
	sta sc_zl
	lda quellspalte
	sta sc_sp
	lda zbreite
	beq rdy
	lda zhoehe
	beq rdy

	lda #0		; clear toggle flag
	sta togg
	sta gr_redisp
sh0	jsr invertcl	; blink clip
	ldx #250
	jsr gd_dl2
	lda togg
	eor #1
	sta togg
	lda $dc00		; fire?
	and #16
	beq sh1		; yes, finish
	lda sy_tbuffer	; any key?
	beq sh0		; no, loop

sh1	lda togg		; finish
	and #1		; clip in blink phase?
	beq sh0		; no, add one blink
	jsr invertcl	; yes, clip to off

	jsr getpos
rdy	jmp dp2		; text mode on, finished

; -------------------------------------- Leading Zero to Space

getzif	jsr gd_xcnvdez	; Byte nach Ziffern
	cpx #$30
	bne +
	ldx #$20
+	rts 

; ------------------------------------------------ Get Mouse Position

getpos	jsr gd_position	; compute position of mouse pointer
	tay		; column: off screen on left?
	lda sc_merk
	sta merk
	tya
	bmi ss14		; yes, reject value
	cmp #40		; off screen on right?
	bcs ss14		; yes, reject
	jsr chcol		; ok, set column value

	lda merk		; row: off screen beyond top?
	bmi ss14		; yes, reject
	cmp #25		; beyond bottom?
	bcs ss14		; yes, reject
	jsr chrow

	lda sc_stop
	bne ss15

	lda zl
	sta zzeile
	jsr chrow
	lda sp
	sta zspalte
	jmp chcol

ss14	ldy #2		; blink border (red)
	pha
	jsr graphon
	bcc +

ss16	jsr yinput	; input values from keyboard
ss15	pha
	beq +

	lda zzeile	; save values (if STOP)
	sta zl
	lda zspalte
	sta sp
+	lda #0
	sta sc_stop
	pla
	rts

; -------------------------------------- Input Target

yinput	ldy #10		; valid chars (digits and space, 11 bytes)
	sty sc_iflag
-	lda zln,y
	sta sy_global,y
	dey 
	bpl -

	lda #<sy_global	; perform Input (result at ls_nambuf)
	ldx #>sy_global
	sta ls_vekta8
	stx ls_vekta8+1
	jsr gd_xinput

	lda #>ls_nambuf	; set vector to ls_nambuf
	sta ls_vekta8+1
	lda #<ls_nambuf
	sta ls_vekta8
	sta sc_iflag
	ldy ls_flen
	sta ls_vekta8,y

; -------------------------------------- Convert Digits to Word (Byte in INT)

gword	ldy #0
	sty int
	sty int+1
	beq +

-	jsr inca8
+	lda (ls_vekta8),y
	cmp #$20
	beq -

	cmp #$3a
	bcs +
	sec 
	sbc #$30
	sec 
	sbc #$d0
	bcs +
	sbc #$2f
	sta merk
	lda int+1
	sta ls_temp
	cmp #$19
	bcs +
	lda int
	asl
	rol ls_temp
	asl
	rol ls_temp
	adc int
	sta int
	lda ls_temp
	adc int+1
	sta int+1
	asl int
	rol int+1
	lda int
	adc merk
	sta int
	bcc -
	inc int+1
	bne -
+	lda int
	rts

; -------------------------------------- 

inca8	inc ls_vekta8
	bne +
	inc ls_vekta8+1
+	rts 

; -------------------------------------- Initialize Position

init	lda #0
	ldx #22
-	sta zl,x
	dex 
	bpl -
	sta sc_keyprs	; clear keyboard
	sta sc_loop	; clear flag for graphics mode
	sta gr_redisp	; clear redisplay flag
	ldx sc_lastclpzl
	ldy sc_lastclpsp
reinit	stx quellzeile
	sty quellspalte
	stx zlmk		; first value row (on fail)
	sty spmk		; first value column (on fail)
	lda sc_lastclpbr
	sta zbreite
	lda sc_lastclpho
	sta zhoehe
	rts 

; ------------------------------------------------ Invert clip area

invertcl	ldx #0		; care for text mode
	stx sc_loop
	jsr gd_initmove	; compute address
inv0	ldy #0		; .y index for width
inv1	cpy zbreite
	beq inv2
	lda sc_vekt20+1
	pha
	lda (sc_vekt20),y	; first invert video ram
	eor #$ff
	sta (sc_vekt20),y
	lda sc_vekt20+1
	clc
	adc #$d4		; then color ram
	sta sc_vekt20+1
	lda (sc_vekt20),y
	eor #$ff
	sta (sc_vekt20),y
	pla
	sta sc_vekt20+1
	iny
	bne inv1		; one row
inv2	inx		; next one
	cpx zhoehe
	beq ready		; finished if height
	jsr gd_plus40	; else add 40 for next
	bne inv0
ready	rts

; ----------------------------------------------------- Blink the Border

graphon	lda rahmen
	pha
	sty rahmen
	ldx #$40
	jsr gd_dl2
	pla
	sta rahmen
	stx sy_tbuffer
	clc
	rts

; ------------------------------------------------ 
; ------------------------------------------------ graphics display
; ------------------------------------------------ 

checkcols	sei 		; GoDot off
	ldx #$00
	stx pport

	ldy #$03		; set lobyte of...
	sty slot

	lda #$f0		; ...Slot4, check for types of module there
	sta slot+1	; (may be cram when input is active)
	jsr sethicol	; (otherwise unchanged)

	lda #$c0		; ...Slot1 and check
	sta slot+1
	jsr sethicol

	lda #$d0		; ...Slot2 and check
	sta slot+1
	jsr sethicol

	lda #$e0		; ...Slot3 and check
	sta slot+1
	jsr sethicol

	lda #$36		; GoDot on again
	sta pport
	cli 
	rts 

; ------------------------------------------------ 

sethicol	lda (slot,x)	; get type of module (at $c003): $20, $40, $80
	tay 
	and #$40		; is saver there? (contains vram1)
	beq +		; no, next type

	jsr c147		; yes, set color buffer 
	sta v1buf
	bne ++

+	tya 		; loader? ($80, contains cram)
	bpl +		; no, next type

	jsr c147		; yes, set accordingly
	sta cbuf
	bne ++

+	jsr c147		; so, it's a modifier (contains vram2)
	sta v2buf

++	rts 

c147 	lda slot+1	; get hibyte...
	ora #$0e		; ...and OR %00001110 to it (ie $ce)
	rts 		; thus: get correct hi address of color buffers

; ------------------------------------------------ 

redisplay	ldx gr_palette	; set border to color 0 (normally black)
	stx rahmen
	jsr setcolors	; get colors from their buffers

	lda gr_cmode	; which mode?
	beq dp4
	lda #$18		; multicolor
	sta multreg
dp4	lda #$1b		; hires
	sta charreg
	lda #$3b
	sta grafreg
	lda gr_redisp	; Flag: display graphics set?
	bne dp3		; yes, branch and leave

; ------------------------------------------------ End display

dp2	jsr getcolors	; no, end display: save colors
	jsr tmode		; activate textmode
oldreq	lda sc_screenvek	; save vector to current screenlist (ClipWorks)
	pha
	lda sc_screenvek+1
	pha
	ldx list		; yes, re-build main screen
	ldy list+1
	jsr gd_screen
dp5	pla		; and then re-build MoveClip requester
	tay
	pla
	tax
	jsr gd_screen
dp3	clc		; leave
	rts

; ------------------------------------------------ Switch textmode on

tmode	ldx #$13
	lda #$1b
	stx charreg
	sta grafreg
	lda #$08
	sta multreg
	lda sc_maincolor
	sta rahmen
	sta backgr
	rts

; ------------------------------------------------ 
; ------------------------------------------------ 
; Routines to handle GoDot's graphics color buffers
; for comments see sources for god.upmem
; ------------------------------------------------ 
; ------------------------------------------------ 

setcveks	sei
	lda #$35
	sta pport
	lda cbuf 		; color ram
	ldx #$d8
	bne scv0
setbveks	lda v1buf 	; vram1
	ldx #4
	dec pport
scv0	stx ls_adrmisc+1
	ldy #0
	sty sc_merk
	sty ls_adrmisc
	dey
setlast	sty gr_bkcol
	ldy #<(cstart)
	sty sc_vekt20
	sta sc_vekt20+1
	lda #<(500)
	sta ls_vekta8
	lda #>(500)
	sta ls_vekta8+1
	ldy #0
	rts

count	inc sc_vekt20
	bne cou5
	inc sc_vekt20+1
cou5	inc ls_adrmisc
	bne cou6
	inc ls_adrmisc+1
cou6	lda ls_vekta8
	bne cou7
	dec ls_vekta8+1
cou7	dec ls_vekta8
	lda ls_vekta8
	ora ls_vekta8+1
	rts

getcolors	jsr setcveks
stco	lda (ls_adrmisc),y
	sta sc_merk
	inc ls_adrmisc
	bne stc0
	inc ls_adrmisc+1
stc0	lda (ls_adrmisc),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lda sc_merk
	sta (sc_vekt20),y
	jsr count
	bne stco
	jsr setbveks
stc1	lda (ls_adrmisc),y
	sta (sc_vekt20),y
	jsr count
	bne stc1
	ldy gr_bkcol
	bpl scv1
	ldy #0
	lda v2buf 	; vram2
	jsr setlast
	beq stc1
scv1	lda #$36
	sta pport
	cli
	lda backgr
	and #15
	sta gr_bkcol
	rts

setcolors	lda gr_bkcol
	sta backgr
	pha
	jsr setcveks
stc2	sty sc_merk
	lda (sc_vekt20),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	sta (ls_adrmisc),y
	inc ls_adrmisc
	bne stc3
	inc ls_adrmisc+1
stc3	lda sc_merk
	sta (ls_adrmisc),y
	jsr count
	bne stc2
	jsr setbveks
stc4	lda (sc_vekt20),y
	sta (ls_adrmisc),y
	jsr count
	bne stc4
	ldy gr_bkcol
	bpl scv1
	pla
	tay
	lda v2buf 	; vram2
	jsr setlast
	beq stc4

; ------------------------------------------------ Display Clip values

tabigad	!wo zielzl
	!wo zielsp
	!wo togclp

settab	lda #<(tabigad)
	sta sc_texttab
	lda #>(tabigad)
	sta sc_texttab+1
	rts

gettab	lda (sc_texttab),y
	sta sc_screentab
	iny
	lda (sc_texttab),y
	sta sc_screentab+1
	iny
	sty sc_merk
	stx sc_merk+1
	lda #$00
	tax
	tay
gt0	jsr gd_setpos
	cpx #$04
	bne gt0
	jsr gd_trim
	jmp gd_initmove

; -------------------------------------- Initialize Activity Bar

initad	ldy #63
	lda #0
-	sta $3fc0,y
	dey 
	bpl -
	sty $3fc0
	sty $3fc1
	sty $3fc2
	lda sc_hilite
	sta $d029
	sta $d02a
	lda $d01d
	ora #$0c
	sta $d01d
	lda $d010
	ora #$0c
	sta $d010
	lda #$08
	sta $d004
	lda #$20
	sta $d006
	lda #$92
	sta $d005
	sta $d007
	sty $07fa
	sty $07fb
	lda $d015
	ora #$0c
	sta $d015
	rts 

; -------------------------------------- Switch Activity Bar off

clearad	lda $d015
	and #$f3
	sta $d015
	lda $d010
	and #$f3
	sta $d010
	rts 

; -------------------------------------- Perform Activity

countad	inc $d005
	inc $d007
	lda $d005
	cmp #$ba
	bmi +
	lda #$92
	sta $d005
	sta $d007
+	rts 

; -------------------------------------- Data

zln	!tx " 0123456789"

zzeile	!by 0
zspalte	!by 0
zbreite	!by 0
zhoehe	!by 0
list	!wo 0
transfl	!by 0
transtx	!scr " dloH fsnarT"

; -------------------------------------- Screenlist

liste	!by 0
	!by 6,13,16,16,$91
	!wo 0
	!scr "MoveClip@"
zielzl	!by 10,17,4,3,$e0
	!wo row 
zzltx	!scr " 0@"
zielsp	!by 10,24,4,3,$e0
	!wo col 
zsptx	!scr " 0@"
	!by 13,13,8,3,$c8
	!wo sevsetcl
	!scr "SetClp@"
togclp	!by 13,21,8,3,$cf
	!wo sevtkover
togtx	!scr " Hold @"	; or "Transf@"
	!by 16,13,8,3,$c8 
	!wo befmove
	!scr "Move@"
	!by 16,21,8,3,$cf
	!wo befcopy
	!scr " Copy@"
	!by 19,13,8,3,$c7
	!wo befchang
	!scr "XChnge@"
	!by 19,21,8,3,$cd
	!wo cancel
	!scr " Exit@"

	!by $c0,8,14,12
	!scr "Destination:@"
	!by $c0,10,13,3 
	!scr "Row@"
	!by $c0,10,20,3 
	!scr "Col@"
	!by $80 

; -------------------------------------- 

modend	!eof
