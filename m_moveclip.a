
	!src "..\godotlib.lib"
	*= $c000
	!ct pet

; --------------------------------------
;
;     mod.MoveClip
;       Modifier zum Kopieren, Verschieben oder Tauschen von Clips
;       innerhalb des 4Bit-Bildes
;     von Martin Burggraf
;
;     1.00, 04.10.95, first release (still buggy)
; 
; -------------------------------------- 


; -------------------------------------- Equates

	pport		= $01
	save		= $02
	zl		= $03
	sp		= $04
	zeile		= $05
	spalte		= $06
	zwisp		= $07	; /$08
	source		= $09	; /$0a
	destin		= $0b	; /$0c
	flag		= $0d
	flag2		= $0e
	colo		= $0f
	quellzeile	= $10
	quellspalte	= $11
	zielzeile		= $12
	zielspalte	= $13
	zielbreite	= $14
	zielhoehe		= $15
	zaehlersp		= $16
	zaehlerzl		= $17
	int		= $18
	wordlo		= $19
	

; -------------------------------------- Header

	jmp start

	!by $20,$00,$01 
	!wo modend
	!wo 0
	!tx "Move the Clip ! "
	!tx "1.00"
	!tx "04.10.95"
	!tx "M.Burggraf      "

; -------------------------------------- Main

start	lda gd_modswitch
	sta save
	jsr init
	ldx #<liste
	ldy #>liste
	jsr gd_screen
	jsr gd_eloop

	lda save
	sta gd_modswitch

	ldy #16		; reset balancing (unused!)
	sty gr_ctr
	sty gr_brt
-	dey 
	tya 
	sta gr_btab,y
	bne -

	lda #15
	sta gr_redisp
cancel	sec 
	rts 

; -------------------------------------- Event: Copy

befcopy	lda #2
	sta flag2
	jmp cliptrans

; -------------------------------------- Event: Move

befmove	lda #1
	sta flag2
	jmp cliptrans

; -------------------------------------- Event: Exchange

befchang	lda #0
	sta flag2
	jmp cliptrans

; -------------------------------------- Event: Input Row of Target

row	jsr yinput
	lda int
	adc zielhoehe
	cmp #25
	bpl +
	sta zeile
	rts 

+	ldy #0
	sty zeile
	jmp prntrowncol

; -------------------------------------- Event: Input Column of Target

col	jsr yinput
	lda int
	adc zielbreite
	cmp #40
	bpl rstcl
	sta spalte
	rts 

rstcl	ldy #0
	sty spalte

; -------------------------------------- Ausgabe der eingegebenen Ziffern

prntrowncol
	ldy zeile		; zuerst: Zeile
	tya 
	tax 
	jsr gd_xcnvdez	; Byte nach Ziffern
	jsr subrout	; führende Null in Space tauschen
	stx sc_movetab	; in Ausgabepuffer schreiben
	sta sc_movetab+1
	ldy #0
	sty sc_movetab+2
	lda #11		; Zielzeile
	sta sc_zl
	lda #18
	sta sc_sp		; Zielspalte
	jsr gd_initmove	; Screenadresse berechnen
	jsr gd_xtxout3	; ausgeben

	ldy spalte	; dann: Spalte dito
	tya 
	tax 
	jsr gd_xcnvdez
	jsr subrout
	stx sc_movetab
	sta sc_movetab+1
	ldy #0
	sty sc_movetab+2
	lda #11
	sta sc_zl
	lda #25
	sta sc_sp
	jsr gd_initmove
	jsr gd_xtxout3
	lda #0
	rts 

; -------------------------------------- Leading Zero to Space

subrout	cpx #$30
	bne +
+	ldx #$20
	rts 

; -------------------------------------- Input Target

yinput	ldy #10		; valid chars (digits and space, 11 bytes)
	sty sc_iflag
-	lda zln,y
	sta sy_global,y
	dey 
	bpl -

	lda #<sy_global	; perform Input (result at ls_nambuf)
	ldx #>sy_global
	sta ls_vekta8
	stx ls_vekta8+1
	jsr gd_xinput

	lda #0		; set vector to ls_nambuf
	sta sc_iflag
	sta ls_vekta8+1
	lda #2
	sta ls_vekta8
	jmp gword		; convert digits to byte value (result in INT)

; -------------------------------------- Initialize Position

init	lda #0
	ldx #22
-	sta zl,x
	dex 
	bpl -
	ldx sc_clipzl
	ldy sc_clipsp
	stx quellzeile
	sty quellspalte
	lda sc_clipbr
	sta zielbreite
	lda sc_clipho
	sta zielhoehe
	rts 

; -------------------------------------- Perform Transport

cliptrans	lda zeile
	sta zielzeile
	lda spalte
	sta zielspalte
	jsr initad
	lda #$ff
	sta zaehlerzl

lp1	lda #0
	sta zaehlersp
	jsr countad	; Move activity bar
	jsr countad
	inc zaehlerzl
	lda zielhoehe	; height complete?
	cmp zaehlerzl
	bpl lp0		; no, transport

	jsr clearad	; finished
	clc 
	rts

; -------------------------------------- 

lp0	lda zaehlersp	; width complete?
	cmp zielbreite
	bpl lp1

	jsr blocktrans	; no, transport
	inc zaehlersp
	jmp lp0

; -------------------------------------- Transport one 4Bit-Tile

blocktrans
	jsr calcblock	; calculate source and target addresses

	ldy #31		; transport 32 bytes (1 tile)
-	sei 
	lda pport
	pha 
	lda #1
	sta pport
	jsr transsub
	pla 
	sta pport
	cli 
	dey 
	bpl -

	rts 

; -------------------------------------- Distributor

transsub	ldx flag2
	beq change
	dex 
	beq move

; -------------------------------------- Perform Copy

copy	lda (source),y	; just source to destination
	sta (destin),y
	rts 

; -------------------------------------- Perform Move

move	lda (source),y	; source to destination, then
	sta (destin),y
	lda colo		; fill source
	sta (source),y
	rts

; -------------------------------------- Perform Exchange

change	lda (source),y	; save source
	pha 
	lda (destin),y	; destination to source
	sta (source),y
	pla 
	sta (destin),y	; re-get source and set destination
	rts 

; -------------------------------------- Calculate Addresses

calcblock	lda quellzeile
	adc zaehlerzl
	sta zl
	lda quellspalte
	adc zaehlersp
	sta sp
	lda #0		; first: source
	sta flag
	jsr clcblksub	; perform calculation

	lda zielzeile
	adc zaehlerzl
	sta zl
	lda zielspalte
	adc zaehlersp
	sta sp
	inc flag		; then: destination

; -------------------------------------- Perform Calculation

clcblksub	lda #$3b		; rows from start of 4Bit ($4000+x*$500)
	sta zwisp+1
	ldx zl
-	lda zwisp+1
	adc #5
	sta zwisp+1
	dex 
	bpl -

	ldx #5		; column from start of row (row+((x*256)and255)))
	lda sp		; .x=5: 5*256=$500 (1 row)
-	asl
	bcc +
	inc zwisp+1
+	dex 
	bne -

	ldx zwisp+1	; Hi addr (lo in .a)
	ldy flag
	bne +
	stx source+1	; set source
	sta source
	rts

+	stx destin+1	; set destination
	sta destin
	rts 

; -------------------------------------- Initialize Activity Bar

initad	ldy #63
	lda #0
-	sta $3fc0,y
	dey 
	bpl -
	sty $3fc0
	sty $3fc1
	sty $3fc2
	lda sc_hilite
	sta $d029
	sta $d02a
	lda $d01d
	ora #$0c
	sta $d01d
	lda $d010
	ora #$0c
	sta $d010
	lda #$08
	sta $d004
	lda #$20
	sta $d006
	lda #$92
	sta $d005
	sta $d007
	lda #$ff
	sta $07fa
	sta $07fb
	lda $d015
	ora #$0c
	sta $d015
	rts 

; -------------------------------------- Switch Activity Bar off

clearad	lda $d015
	and #$f3
	sta $d015
	lda $d010
	and #$f3
	sta $d010
	rts 

; -------------------------------------- Perform Activity

countad	inc $d005
	inc $d007
	lda $d005
	cmp #$ba
	bmi +
	lda #$92
	sta $d005
	sta $d007
+	rts 

; -------------------------------------- Convert Digits to Word (Byte in INT)

gword	ldx #0
	stx int
	stx int+1
-	jsr inca8
	lda (ls_vekta8),y
	cmp #$20
	beq -
	cmp #$3a
	bcs +
	sec 
	sbc #$30
	sec 
	sbc #$d0
	bcs +
	sbc #$2f
	sta wordlo
	lda int+1
	sta ls_temp
	cmp #$19
	bcs +
	lda int
	asl
	rol ls_temp
	asl
	rol ls_temp
	adc int
	sta int
	lda ls_temp
	adc int+1
	sta int+1
	asl int
	rol int+1
	lda int
	adc wordlo
	sta int
	bcc -
	inc int+1
	bne -
+	lda int
	rts

; -------------------------------------- 

inca8	inc ls_vekta8
	bne +
	inc ls_vekta8+1
+	rts 

; -------------------------------------- Screenlist

liste	!by 0,6,13,16,13,$91
	!wo 0
	!scr "MoveClip@"
	!by 10,17,4,3,$e0
	!wo row 
	!scr " 0@"
	!by 10,24,4,3,$e0
	!wo col 
	!scr " 0@"
	!by 13,13,8,3,$c8 
	!wo befmove
	!scr "Move@"
	!by 13,21,8,3,$cf 
	!wo befcopy
	!scr " Copy@"
	!by 16,13,8,3,$c7 
	!wo befchang
	!scr "Change@"
	!by 16,21,8,3,$cd
	!wo cancel
	!scr " Exit@"
	!by $c0,8,13,12
	!scr "Destination:@"
	!by $c0,10,13,3 
	!scr "Row@"
	!by $c0,10,20,3 
	!scr "Col@"
	!by $80 

; -------------------------------------- Valid Chars on Input

zln	!tx " 0123456789"

; -------------------------------------- 

modend	!eof
