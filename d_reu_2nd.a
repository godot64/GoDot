; .petscii
; .include "godotlib.lib"
; .ob "d_reu0,w"

; --------------------------------------
;
; dev.REU - REU handler routines, Section 2
; 1.00, 15.02.93, first release
; 1.01, 04.07.93
; 1.02, 21.04.94, bugfix: no delete of first entry when buffer full
; 1.03, 23.09.03, bugfix: no dir when buffer full
;
; -------------------------------------- 

!src "..\godotlib.lib"
*= $bd00

; -------------------------------------- Equates

	low		= $30
	high		= $31
	zwischen		= $32
	hold		= $38
	entry		= $3a
	cntlns		= $3c

	swap4096		= $1714
	chgtxt		= $18ad
	lderr		= $18fc
	bindex		= $1c43
	units		= $1cf8
	blocks		= $3f40

	swapfile		= $b21c
	dirbuf		= $bf00
	modul		= $c000

; -------------------------------------- 

ramdir	jsr first		; Funktion 2: Directory
dir	ldx #0
	ldy rm_nextentry
	cpy #140		; max. 139 Einträge
	bcc rd5
	dey
rd5	tya
	jsr mal19
rd1	ldy #0
	lda (entry),y	; Ende erreicht? ($c0)
	cmp #$c0
	beq nxt2		; ja, fertig

	and #$f0		; Filetyp plausibel?
	ldy #4
rd3	cmp types,y
	beq rd2		; ja, weiter
	dey
	bpl rd3
	bmi rnxt		; nein, überspringen

rd2	lda #2		; (Dummy-) Filetyp im Directory-Record eintragen
	jsr bindex
	sta dirbuf,x
	ldy #1
	inx
rd0	lda (entry),y	; Filenamen eintragen
	sta dirbuf,x
	inx
	iny
	cpy #19		; ein Record ist 19 Bytes lang
	bne rd0

	inc cntlns	; neue Zeile (zählt bis 16)
rnxt	inc rm_nextentry	; nächster Eintrag

nxt2	sty dirbuf	; wenn Ende des Directory: .y=0
	lda #32		; Ausgabepufferzeiger erhöhen
	jsr bindex
	sta ls_index	; .x ist Offset auf nächsten Eintrag
	bcs show		; wenn Puffer voll (8 Einträge): Directory anzeigen, .x=0

		; ### 23.09.03
nxt3	lda #0
	sta dirbuf+2,x	; Eintrag aus dem letzten Anzeigedurchgang unkenntlich machen (auf DEL setzen)
	beq dir

show	jsr gd_makedir	; Directory anzeigen
	php		; kehrt zurück mit Info, ob Anzeige voll (16 Zeilen erreicht)
	ldx #0
	plp
	bne nxt3		; wenn nicht: weiter
		; ### bis hier

	sta cntlns	; Zeilenzähler (16, wenn beendet)
	clc
	rts

; -------------------------------------- Padding

	!pet "GoDot"

; -------------------------------------- Init Dir

first	ldx #0		; Directory-Puffer löschen
	txa
ft0	sta dirbuf,x
	inx
	bne ft0
	stx rm_nextentry	; Eintragszähler    auf 0
	stx cntlns	; Zeilenzähler      auf 0
	stx ls_index	; Offset-Zeiger     auf 0
	stx ls_lines	; Hauptzeilenzähler auf 0
	stx ls_cblocks	; Blockzähler 2     auf 0
	inx
	stx blocks	; Blockzähler 1     auf 1
	stx blocks+1
	stx dirbuf	; Directorypuffer markieren
	stx dirbuf+1
	rts

; -------------------------------------- Multiply .a with 19

mal19	sta entry
	sta hold
	stx entry+1
	stx hold+1
	beq m2
	asl hold
	rol hold+1
	clc
	lda hold
	adc entry
	sta entry
	bcc m1
	inc entry+1
m1	asl hold
	rol hold+1
	asl hold
	rol hold+1
	asl hold
	rol hold+1
	clc
	lda entry
	adc hold
	sta entry
	lda entry+1
	adc hold+1
m2	ora #$c0
	sta entry+1
	rts

; -------------------------------------- Scroll

scroll	dey		; Funktion 5: Scroll Directory
	bne scrdn
scrup	ldx #8
	!byte $2c
scrdn	ldx #24
	stx hold
	sec
	lda rm_nextentry
	sbc hold
	bcs scr0
	lda #0
scr0	sta rm_nextentry
	lda #1
	jsr gd_sun2
	ldx #1
	stx sc_zl
	dex
	stx cntlns
	stx ls_lines
	stx ls_index
	jmp dir

	!byte $ad		; Padding
	
; -------------------------------------- Install to REU

rsave	ldx #0		; Funktion 6: Install Module
	lda rm_nextram
	jsr mal19
	lda modul+3
	sta rm_werte+4
	tya
	ldy #0
	ora rm_werte+4
	sta (entry),y
	iny
	lda modul+1
	sta rm_werte+2
	sta (entry),y
	iny
	lda modul+2
	sta rm_werte+3
	sta (entry),y
	jsr gd_swapd
	lda modul+6
	sta rm_werte+5
	sec
	lda modul+7
	sbc #$c0
	sta rm_werte+6
	lda #$90
	jsr gd_reu
	lda reubase+4
	pha
	lda reubase+5
	pha
	lda reubase+6
	and #7
	pha
	jsr gd_swapd
	pla
	sta modul+3
	pla
	sta modul+2
	pla
	sta modul+1
	ldx #0
	ldy #3
rs0	lda ls_nambuf,x
rs1	sta (entry),y
	iny
	inx
	cpx rm_rlen
	bcc rs0
	lda #32
	cpx #16
	bcc rs1
	inc rm_nextram
rs2	jmp gd_swapd

; -------------------------------------- Transfer data

rldex	jsr gd_swapd	; Entry for #3 and #4: Dir ausblenden
	jsr gd_getback	; Execution Area mit Slot x (in gd_modswitch) tauschen
	ldx rm_ramfunc	; Funktionsnummer holen
	cpx #3		; #3?
	bne lm4		; nein, Sprung
	
; -------------------------------------- F#3

	jsr getit		; Funktion 3: Load Module - aus REU laden (getit)
	jsr gd_getback	; an seinen Platz verschieben (Slot x)
	jsr chgtxt	; Namen eintragen
	jmp exrdy		; und ForceOff (dabei Dir ausblenden), fertig

; -------------------------------------- F#4

lm4	jsr lm3		; Funktion 4: Execute Module
	jsr gd_swapd	; Dir einblenden

exrdy	ldx #0		; Abschluss:
	stx ls_flen
	inx		; F#1 ausführen: ForceOff (.x=1)
	jsr rm_ramvec	; execute (dabei Dir ausblenden)
	sec		; Modul verlassen, fertig
	rts
;
; -------------------------------------- 

lm3	lda #<(swapfile)	; aktuelles Modul in Sicherheit bringen (ins Swapfile)
	sta rm_swapw+2
	lda #>(swapfile)
	sta rm_swapw+3
	lda #<(3500)
	sta rm_swapw+5
	lda #>(3500)
	sta rm_swapw+6
	jsr gd_swapd	; (swapd wird hier "missbraucht")

	jsr getit		; das neue Modul laden
	lda modul+5	; Dirty?
	bne noexec	; dann skip execute

	ldx sc_scvek2	; GoDot-Screen aufbauen (File-Requester aus)
	ldy sc_scvek2+1
	jsr gd_screen
	jsr modul		; und Modul ausführen

lm5	jsr gd_swapd	; danach aktuelles Modul aus Swapfile zurückholen
	iny		; .y=0
	sty rm_swapw+2	; und swapd-Record nach Missbrauch reparieren
	sty rm_swapw+3
	sty rm_swapw+5
	lda #$10
	sta rm_swapw+6
	jmp gd_getback	; Slot x zurückholen nach Execution Area, fertig

; -------------------------------------- Reject when Dirty

noexec	jsr gd_clrms
	ldx #<(mess)	; Message in der Statuszeile ausgeben
	ldy #>(mess)
	jsr gd_xtxout2
	jsr lm5		; aktuelles Modul zurückholen
	pla		; Rücksprung nach lm4 vom Stack löschen
	pla
	clc		; fertig,
	bcc rs2		; Dir ausblenden

; -------------------------------------- Get Module from REU

getit	lda #$91		; Fetch
	jsr gd_reu
	jmp gd_spron

; --------------------------------------

types	!byte $00,$80,$40,$f0,$20
mess	!scr "Only loadable.@"

; --------------------------------------

	!eof
