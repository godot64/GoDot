
!src "..\godotlib.lib"

; ***---------------------------------------------------***
; ***                                                   ***
; ***  GoDot UpMem 1.14                                 ***
; ***  Preview Routines                                 ***
; ***                                                   ***
; ***---------------------------------------------------***
;

; Declarations

	lflag		= $a8
	brttmp		= $a9
	crttmp		= $aa

	sprptr		= $07fa
	spr2		= $3e80
	spr5		= $3f40

	dbuf		= $bf00

	sprxy		= $d004
	spritehi		= $d010
	sprreg		= $d015
	yexp		= $d017
	sprpri		= $d01b
	sprmulti		= $d01c
	xexp		= $d01d
	sprcol2		= $d025
	sprcol3		= $d026
	sprcol1		= $d029


;
; All GoDot modules run at $c000 (Execution Area)
; but note that this is not the true location of Preview
;
	*= $c000
;
; -------------------------------------------------
; When entering this event routine you have just clicked the 
; appropriate gadget. So, all values are still set here and now.
; The event routine first reverts the gadget's background.
;

evprviu	jsr gd_initmove	; compute screen address
	pha		; A-reg contains sc_vekt20+1
	lda sc_vekt20
	pha
	jsr gd_invert	; reverting to black

	ldx #$c0		; make space for three sprites...
	ldy #$00
loop1	lda spr2-1,x
	sta dbuf-1,x
	tya
	sta spr2-1,x	; and initialize to $00
	dex
	bne loop1

	ldx #$c0		; initialize three more sprites
loop2	sta spr5-1,x
	dex
	bne loop2

	sta sprpri	; priority
	sta xexp		; no expansion
	sta yexp

	lda #$fc		; sprites 2 to 7: multi mode
	sta sprmulti

	ldx #$05		; colorize: mid gray
	lda #$0c
loop3	sta sprcol1,x
	dex
	bpl loop3
	lda #$0b		; dark gray
	sta sprcol2
	lda #$0f		; light gray
	sta sprcol3

	ldx #$0b		; define positions (in gadget)
loop4	lda xytab,x
	sta sprxy,x
	dex
	bpl loop4
	lda spritehi	; beyond 255
	ora #$fc
	sta spritehi

	ldx #$05		; activate sprite pointers
	ldy #$ff
ploop	tya
	sta sprptr,x
	dey
	dex
	bpl ploop

	lda #$ff		; switch sprites on
	sta sprreg
;
; Now rendering the 4Bit Area to the sprites. Will be done as three
; bands of 12 tiles down from left to right.
; 
	ldx #$02		; three times 12 tiles (20 rows down)
m0loop	txa
	pha
	lda srcl,x	; set source address (4Bit)
	sta sc_pos
	lda srch,x
	sta sc_pos+1
	lda dstl,x	; set destination address (sprites)
	sta sc_loop
	lda dsth,x
	sta sc_loop+1
	lda #$00		; counter to skip byte 63 in sprite
	sta sc_screentab
	jsr makeit	; render one band
	pla
	tax
	dex
	bpl m0loop	; and the next two
;
; now rendered, wait for click to shut down sprites
; 
	inx		; wait for click
	stx sc_keyprs
wait	lda sc_keyprs
	beq wait
;
	lda #3		; only sprites 0+1 remain (mouse)
	sta sprreg
	lda spritehi		; force to lower 256 position
	and #$03		; (sometimes flickers, can't imagine why)
	sta spritehi

	pla		; restore gadget address
	sta sc_vekt20
	pla
	sta sc_vekt20+1
	jsr gd_invert	; revert to blue again

	ldx #$c0		; restore rendered image from buffer
piu0	lda dbuf-1,x
	sta spr2-1,x
	dex
	bne piu0

	clc		; don't leave screenlist
	rts
;------------------------------------------------------------------
;
; rendering 4Bit Area to 6 sprites
;
;------------------------------------------------------------------
makeit	ldx #$00		; MUST be $00!
	ldy #$14		; 20 rows of tiles down

prloop	tya		; start preview loop
	pha
	lda #$40		; flag: %0100 0000, 2 passes per tile
	sta lflag

dzloop	lda #$03		; flag: 3 passes across
	sta brttmp

zloop	ldy #$60		; 4 tiles from right to left
	lda lflag		; on 2nd pass (tile): 
	bpl bloop
	ldy #$70		; indent to 4 pixels below

bloop	lda (sc_pos),y	; get 4bit data
	lsr
	lsr
	lsr
	ror crttmp
	lsr
	ror crttmp

	tya		; next tile (to the left)
	sec
	sbc #$20
	tay
	bpl bloop

	lda crttmp	; byte complete, write to sprites
	sta (sc_loop,x)

skip64	inc sc_loop	; increment destination pointer
	bne s1
	inc sc_loop+1

s1	inc sc_screentab	; skip byte 63
	lda sc_screentab
	cmp #$3f
	beq skip64

	lda sc_pos	; add to 4 tiles ahead
	clc		; (summing up to 12 tiles at last)
	adc #$80
	sta sc_pos
	bcc skip
	inc sc_pos+1

skip	ror brttmp	; loop for next two passes across
	bcs zloop

	lda sc_pos	; 3 times 4 tiles backwards
	sec
	sbc #$80
	sta sc_pos
	lda sc_pos+1
	sbc #$01
	sta sc_pos+1

	rol lflag		; loop for second pass within tile
	bcc dzloop

	lda sc_pos	; add $500 (1280): next row of tiles
	clc
	adc #$00
	sta sc_pos
	lda sc_pos+1
	adc #$05
	sta sc_pos+1

	pla		; count 20 times
	tay
	dey
	bpl prloop
	rts		; until finished
;-------------------------------------------------------------
; Data (screen positions and so on)
;-------------------------------------------------------------
srcl	!by $40,$c0,$40	; not from leftmost position!
srch	!by $4d,$4b,$4a

dstl	!by $80,$00,$80	; sprite block addresses
dsth	!by $3f,$3f,$3e

xytab	!by $07,$91,$07,$a6
	!by $1f,$91,$1f,$a6
	!by $37,$91,$37,$a6
	!by $00

modend	!eof
