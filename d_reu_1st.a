
!src "..\godotlib.lib"
*	= $c000

; --------------------------------------
;
; dev.REU - REU handler routines
;
;   1.00, 08.03.02, first release
;   1.01, 04.07.93, TEMP included
;   1.02, 21.04.94, made second dirblock invisible if empty
;   1.03, 15.02.95, adapted to changed kernel variables
;   1.04, 23.09.03, bug: double files in DIR fixed
;   1.05, 28.08.16, bug: Undo 4Bit could fail
; 
; -------------------------------------- 


; -------------------------------------- Equates

	low		= $30
	high		= $31
	zwischen		= $32
	hold		= $38
	entry		= $3a
	cntlns		= $3c

	swap4096		= $1714
	chgtxt		= $18ad
	lderr		= $18fc
	bindex		= $1c43
	units		= $1cf8
	blocks		= $3f40

	swapfile		= $afc8
	rdir		= $bd00
	mal19		= $bd8c
	rscroll		= $bdc1
	rsave		= $bded
	rldex		= $be65
	back		= $befd
	dirbuf		= $bf00
	modul		= $c000

; -------------------------------------- Header

ramdev	jmp start

	!by $10,0,0
	!wo modend
	!wo 0
	!pet "REU Handler     "
	!pet "1.05"
	!pet "28.08.16"
	!pet "A. Dettke       "

; -------------------------------------- Main

start	stx rm_ramfunc	; Funktion in .x
	beq rinit

	dex
	beq forceoff
	dex
	beq jrdir
	dex
	beq jrinst
	dex
	beq jrexec
	dex
	beq jrscroll
	dex
	beq jrsave
	dex
	beq jralloc
	dex
	beq jrdoundo
	dex
	beq jrgetundo
	dex
	beq init0

cont	clc
	rts

; -------------------------------------- Func 1: Cancel

forceoff	ldx #0
	jsr foff2
	jmp gd_swapd

; --------------------------------------

jrdir	jmp rdir		; func 2: Directory
jrsave	jmp rsave		; func 6: Install
jrinst	jmp ramldex	; func 3: Load MOD, Save Temp
jrexec	jmp ramldex	; func 4: Exec MOD
jrscroll	jmp rscroll	; func 5: Scroll Directory
jralloc	jmp ralloc	; func 7: Avail Mem
jrdoundo	jmp un2		; func 8: Do Undo (from REU)
jrgetundo	jmp gt2		; func 9: Get Undo (to REU)

; -------------------------------------- Func 0: Init

rinit	jsr init0		; exec f10
	lda munits	; 1st time?
	bne rin3
	jsr in6		; yes, set units in filerequester to label "restore"

rin3 	lda #<(rrun)	; write "Execute" to "Delete"-Gadget
	ldx #>(rrun)
rin1 	sta sc_screentab
	stx sc_screentab+1
	lda #0
	tax
	tay
	stx sc_loop
rin2 	jsr gd_setpos
	cpx #$03
	bne rin2
	jsr gd_trim
	jsr gd_initmove
	ldy #$02
	jmp gd_xtxout1

; -------------------------------------- Func 10: First Init

init0	lda #<(modend)	; write device to $bd00 (appended after MODEND)
	ldx #>(modend)
sinit	sta sc_pos
	stx sc_pos+1
	ldy #$00
	lda #>(rdir)
	sty sc_texttab
	sta sc_texttab+1
in0  	lda (sc_pos),y
	sta (sc_texttab),y
	inc sc_pos
	bne in1
	inc sc_pos+1
in1 	inc sc_texttab
	bne in2
	inc sc_texttab+1
in2	lda sc_texttab+1
	cmp #$bf
	bne in0
in3	rts

; -------------------------------------- Modify Units vector in Filerequester

in6	lda units		; save units vector (in screenlist of filerequester)
	sta munits
	lda units+1
	sta munits+1
	lda #<(restore)	; change to label "restore"
	ldx #>(restore)
in5	sta units
	stx units+1
	rts

; --------------------------------------

rrun 	!by 10,25,11
	!scr " Execute @"
rdel 	!by 10,25,11
	!scr " Delete  @"

munits	!wo 0

; -------------------------------------- Restore Units vector

restore 	lda sc_merk	; Mausklick-Zeile plus 5
	clc
	adc #5
	cmp ls_drive	; gleich aktueller Drive? 
	beq norest	; dann nichts tun
	jsr rest2		; sonst: "Delete" ins "Delete"-Gadget schreiben

norest	jmp se_units	; Units anzeigen

rest2	lda #<(rdel)	; Zeiger auf "Delete"
	ldx #>(rdel)
	jsr rin1		; eintragen (Teil von f0)
foff2	lda munits	; Units-Vektor rekonstruieren
	beq f2
	stx munits
	ldx munits+1
	jsr in5
f2	rts

; -------------------------------------- func 3 (Load), 4 (Execute), Save Temp

ramldex 	ldy #1		; search for dir-entry
	sty rm_nextentry
lm2	ldx #0
	tya
	jsr mal19
	ldy #3
lm0	lda (entry),y
	cmp ls_nambuf,x
	bne lm1
	iny
	inx
	cpx ls_flen
	bne lm0

	ldy #0		; set address
	lda (entry),y
	sta rm_werte+4	; bank
	iny
	lda (entry),y
	sta rm_werte+2	; offset lo
	iny
	lda (entry),y
	sta rm_werte+3	; offset hi

	lda ls_dirmask	; Grafik?
	beq undo		; ja, dann Save Temp oder Undo

	lda #$ac		; sonst: Execute (in dev, Teil2)
	sta rm_werte+5	; dazu: 3500 Bytes (Länge SWPFILE) austauschen
	lda #$0d
	sta rm_werte+6
	jmp rldex		; Sprung dorthin
;
lm1	inc rm_nextentry	; nächsten Eintrag ansteuern
	ldy rm_nextentry
	cpy rm_nextram	; bis alle durch
	bcc lm2
	beq lm2
	clc		; keiner gefunden, nichts tun
	rts

; -------------------------------------- func 8 und 9: Undo

undo 	jsr tempr		; Temp? (bleibt dort, wenn ja)
	bne un0		; nein, Undo
	jmp getundo	; 0: f9, Save Undo to REU

un0	jsr un2		; 1: f8, Load Undo (fetch undo from REU)
un3	bcc rdy2
	jmp forceoff

; -------------------------------------- f8: Undo (holen)

un2	lda #$91		; $91 = fetch
	sta rm_combuf
	ldy rm_ramundo	; 1=4Bit, 2=Rendered
	lda rm_nextentry
	cpy #1		; 4Bit?
	bne urend		; nein, Sprung
	
; -------------------------------------- Undo 4Bit

u4bit	tya		; Undo vorhanden?
	and #1
	beq un1		; nein

	sta gr_redisp
getit1	lda #<(32000)	; Anzahl Bytes
	ldx #>(32000)
	ldy #$40		; nach $4000
	bne getit2

getit	lda #<(500)	; Farb-RAM (500 Bytes)
	ldx #>(500)

getit2	sta rm_werte+5
	stx rm_werte+6
	sty rm_werte+1
	lda rm_combuf
	jsr gd_reu	; ausführen
	iny
	sty ls_flen
	ldx #>(modul)	; REU-Record re-initialisieren
	stx rm_werte+1
undordy 	jsr gd_spron	; Mauszeiger an
	sec		; fertig
rdy2 	rts

; -------------------------------------- Undo Rendered

urend	tya		; Undo vorhanden?
	and #2
un1	beq noundo	; nein

	lda bkundo	; Hintergrundfarbe rekonstruieren
	sta gr_bkcol
getit3	lda rm_combuf	
	pha
	lda #$90		; $9000 mit REU-Anfang (DIR) tauschen
	sta rm_swapw+1
	jsr gd_swapd
	pla
	sta rm_combuf
	lda #<(8000)	; 8000 Bytes aus UndoR nach $2000
	ldx #>(8000)
	ldy #$20
	jsr getit2

	jsr getit4	; Farbram (500 Bytes)
	ldy #$0b
	sty rm_werte
	ldy #$9e		; ab $9e0b (nach $ac40)
	jsr getit

	jsr getit5	; Vram 1 (500 Bytes)
	jsr swapd0	; Saver einblenden
	ldy #$0b
	sty rm_werte
	ldy #$8e		; ab $8e0b (nach $ae34)
	jsr getit
	jsr swapd0	; Saver wieder ausblenden

	jsr getit6	; Vram 2 (500 Bytes)
	jsr swape0	; Modul einblenden
	ldy #$0b
	sty rm_werte
	ldy #$8e		; ab $8e0b (nach $b028)
	jsr getit
	jsr swape0	; Modul wieder ausblenden

	sty rm_werte	; .y=0 
	jsr gd_swapd	; $9000 wieder zurücktauschen
	lda #>(modul)	; und $c0 für DIR rekonstruieren
	sta rm_swapw+1
	rts

; -------------------------------------- No Undo available

noundo	jsr gd_clrms	; Meldung: "Buffer empty."
	ldx #<(mess)
	ldy #>(mess)
	jmp gd_xtxout2

; -------------------------------------- f9: Undo to REU (sichern)

getundo 	jsr gt2		; durchführen
	jmp un3		; abschließen
;
gt2	lda #$90		; $90 = Stash
	sta rm_combuf
	lda rm_nextentry	; welches Undo?
	cmp #1		; 4Bit?
	bne getrend	; nein
;
get4bit 	jsr getit1	; ja, 4Bit
	lda #1
gt4	ora rm_ramundo	; Flag setzen
	sta rm_ramundo
	jmp undordy
;
getrend 	jsr getit3	; Rendered
	lda gr_bkcol	; Hintergrundfarbe ebenfalls retten
	sta bkundo	; abschließen
	lda #2
	bne gt4
;
; -------------------------------------- 

getit4	lda #$40		; Vram 1
	ldx #$ac
	bne gt5
getit5	lda #$34		; Vram 2
	ldx #$ae
	bne gt5
getit6	lda #$28		; Cram
	ldx #$b0
gt5	sta rm_werte+2
	stx rm_werte+3
	rts

; --------------------------------------

swapd0	lda #$d0		; Saver
	!by $2c
swape0	lda #$e0		; Modifier
	ldx #$80
	jmp swap4096

mess 	!scr "Buffer empty.@"

bkundo	!by 0		; Hintergrundfarbe

; -------------------------------------- (Save/Load) Temp routines

tempr	ldy ls_loadsave	; load (1) oder save (0)?
	lda rm_nextentry	; was überhaupt?
	cmp #3
	bcs temp0		; Entry größer 3: Temp00
	tya		; sonst: Undo (f8/f9)
	rts

temp0	tya		; load/save?
	bne ltmp

; -------------------------------------- Save Temp

stmp 	lda #<(strut)	; verlegen nach Global
	ldx #>(strut)
	sta sc_texttab
	stx sc_texttab+1
	ldy #0
st01 	lda (sc_texttab),y
	sta sy_global,y
	iny
	cmp #$60
	bne st01
	jmp sy_global	; dort ausführen:
;
strut	lda gd_modswitch	; Modulherkunft retten
	pha
	ldy #$ff		; SAVE erzwingen
	jsr se_save	; durchführen (Saver Temp aufrufen)
	php		; Ergebnis nach .y retten
	pla
	tay		
	pla		; Modulherkunft rekonstruieren
	sta gd_modswitch
	pla		; Rücksprung nach label "undo" verwerfen
	pla
	tya		; Ergebnis von SAVE rekonstruieren
	pha
	jsr forceoff	; Device ausblenden (darum diese Routine an Global)
	plp
	rts		; fertig

; -------------------------------------- Load Temp

ltmp 	lda rm_ramundo	; Flag retten (welches RAM)
	pha
	ldy #1		; fake auf 1, scheinbar Undo 4Bit ansteuern,...
	sty rm_ramundo
	sty rm_nextentry
	jsr un2		; ...aber Temp00 holen (Bank und Offset wurden in ramldx gesetzt)
	pla
	sta rm_ramundo	; Flag rekonstruieren
	pla		; Rücksprung nach label "undo" verwerfen
	pla
	jmp forceoff	; Device ausblenden

; -------------------------------------- Func 7: Avail Mem

ralloc	sta low		; RAM-Anforderung in .a/.y (lo/hi)
	sty high		; wenn 0: Wie viel Platz ist übrig? (Antwort in .a und Carry)
	ora high		; war 0?
	bne doesfit	; nein, berechnen: passt Anforderung?

howmuch 	lda ls_ramdrive	; RAM-Typ ermitteln
	and #15
	sta zwischen	; Typ mal 3: Offset auf Info
	asl
	clc
	adc zwischen

	tax		; Info einlesen
	lda kapaz,x
	bmi fehler	; dieses RAM gibt es nicht

	sta back+2	; sonst: Info auswerten
	lda kapaz+1,x
	sta back+1
	lda kapaz+2,x
	sec
	sbc modul+1
	sta back
	lda back+1
	sbc modul+2
	sta back+1
	lda back+2
	sbc modul+3
	sta back+2	; Ergebnis in back ($befd-$beff)
fehler	rts

doesfit 	jsr howmuch	; zuerst: Kapazität berechnen
	sec		; dann: Anforderung subtrahieren
	lda back		
	sbc low
	lda back+1
	sbc high
	lda back+2
	sbc #0
	bcs okay

kapaz	lda #0		; passt nicht (clc)
	!by $2c
okay 	lda #$ff		; passt (sec)
	rts

; -------------------------------------- RamTypes

	!by 1,0,0		; VDC 2 	( 64 KB)
	!by 0,$80,0	; PageFox ( 32 KB)
	!by 4,0,0		; 1764	(256 KB)
	!by 8,0,0		; 1750	(512 KB)
	!by $ff,$ff,$ff
	!by $ff,$ff,$ff
	!by 2,0,0		; 1700 	(128 KB)

; --------------------------------------

modend	!eof


