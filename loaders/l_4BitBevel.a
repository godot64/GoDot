
	!src "godotlib.lib"
	*= $c000
	!ct pet
;	!sl "labels.txt"

; ----------------------------------------- 
;
; ldr.4Bit&Bevel
; Lader zum Abschrägen von Kanten
; (derived from ldr.4Bit&Map)
;
; 1.00, 17.02.20: first release
;
; ----------------------------------------- 


; ----------------------------------------- Equates

	packbyte	= $ad	; Konstante

	filetype	= $30
	counter	= $31
	gbyte	= $33
	pfvek	= $34
	pfbank	= $36
	brmerk	= $37
	readvek	= $38
	dst	= $3a
	bbreite	= $3c
	rrand	= $3e
	adcnt	= $3f
	skip	= $40
	doit	= $42
	byte	= $44
	fbyte	= $45

	status	= $90

	offx	= $b2
	offy	= offx+1

	vdc	= $d600
	vdcdata	= $d601
	bswitch	= $de80

; ----------------------------------------- Header

header	jmp start
	!by $80
	!by 4
	!by 1
	!wo modend
	!wo 0
	!pet "4Bit&Bevel      "
	!pet "1.00"
	!pet "17.02.20"
	!pet "A.Dettke        "

; ----------------------------------------- Leave

evcancel	lda #$ff
	sta which

cancel	lda #$ff
	sta used
cn2	sec
	rts

; ----------------------------------------- Subs

jrequ	jmp requ
jerror	jmp error

; ----------------------------------------- Main

start	ldx used
	bmi jrequ
	beq cancel
	cpx #3
	bcs cancel

; ----------------------------------------- Einlesen vorbereiten

st0	ldy #0
	sty breite
	sty breite+1
	sty bbreite
	sty bbreite+1
	sty filetype
	jsr setfull	; Startadressen setzen
	jsr gd_sproff	; Sprites aus

	jsr setsource	; .a=flag4 (load source)
	beq ob7		; 0=Disk

	cmp #1		; 1=Temp
	bne ob6
	jsr srt2
	bcc ld61

ob6	cmp #3		; 2=Undo/3=VDC2
	beq ld61
	jsr srt7
	bcc ld61

; ----------------------------------------- Read from Disk

ob7	jsr getname	; Filenamen merken
	jsr gd_xopen	; file öffnen

	jsr onebyte	; Kennung einlesen: "G"
	bne jerror
	tay		
	beq ld60		; nein, $00? Dann ungepackt, Startadresse überlesen
	jsr onebyte	; "O"
	bne jerror
	jsr onebyte	; "D"
	bne jerror
ld60	jsr onebyte	; Ziffer: "0" (Bild) oder "1" (Clip) oder Hi Startadresse
	bne jerror
	sta filetype
	tya		; war ungepackt ($00)?
	bne ld61
	sta filetype	; dann zum Filetype machen

; ----------------------------------------- 

ld61	asl filetype	; "lesbarer" machen (aus $30 wird $60, aus $31 wird $62)
	lda filetype
	and #2		; Clipfile?
	beq ob5

	jsr getfclip	; ja, Daten einlesen: Zeile, Spalte, Breite, Höhe
	lda clpbr		; neue Breite für Full
	sta brmerk
	jsr gbh2		; mal 32 für 4Bit

ob5	ldx which		; Modus:
	bne ld62		; Replace? (which=0)
	jsr setrplc	; Distributor auf Replace setzen
	jsr getname	; dann: Filenamen merken

ld62	jsr gd_clrms	; Messages und Activity initialisieren
	jsr clrmess
	sty counter
	sty counter+1
	lda #200
	sta adcnt

; ----------------------------------------- Bild holen

ld0	ldx breite	; Bytezähler für Zeile
	stx ls_vekta8
	ldy breite+1
	sty ls_vekta8+1
	ldx bbreite
	stx skip		; bei Clips: Skip rechts
	ldy bbreite+1
	sty skip+1

ld01	ldy #0
	jsr readfile	; read byte
	ldx status	; Floppyfehler?
	bne ld5		; ja, abbrechen
	jsr readbytes	; process byte (via doit)
	tax
	lda skip		; Skip?
	ora skip+1
	beq ld1
	txa		; buffer result
	sta (sc_texttab),y
	inc sc_texttab
	bne ld10
	inc sc_texttab+1
ld10	lda skip		; Skipzähler
	bne ld11
	dec skip+1
ld11	dec skip
ld1	lda ls_vekta8	; Bytezähler
	bne ld2
	dec ls_vekta8+1
ld2	dec ls_vekta8
	jsr action

	lda status
	bne ld5
	lda ls_vekta8
	ora ls_vekta8+1
	bne ld01		; Zeile fertig bei 0

; ----------------------------------------- 

	clc		; nächste Zeile $500 tiefer
	lda dst+1
	adc #5
	sta dst+1
	sta sc_texttab+1
	lda dst
	sta sc_texttab
	dec hoehe		; File fertig bei 0
	bne ld0

; ----------------------------------------- Abschluss

ld3	lda flag4		; RAM-Erweiterung?
	bne ld6		; ja, dort weiter

	ldx which		; Modus?
	bne ld5		; nicht Load, dann skip

	lda (doit,x)	; check for Load or Bevel
	cmp #$60		; is Load? (Code for RTS)
	bne ld5		; no, don't create Image Info 	# -- bis hier
	jsr setinfo

ld5	jsr gd_xclose	; File schließen
	jsr gd_xmess	; Floppy-Meldung

ld7	jsr gd_spron	; Mauszeiger an
	jmp cancel	; Abschluss

; ----------------------------------------- 

ld6	jsr srt4		; REU initialisieren
	jsr vw2		; Main-Screen aufbauen
	jmp ld7		; weiter wie oben

; ----------------------------------------- 

readbytes	jmp (doit)	; distributor

; ----------------------------------------- 

error	jsr ld5		; close file
	clc		; stay
	rts

onebyte	jsr basin
	ldx status
	rts

; ----------------------------------------- Variablen

flag4	!by 0
banks	!by $ff,$ff,0,0,3,7,$ff,$ff,1,0
bank	!by 7
ramtype	!by 0
howmany	!by 0
bbuf	!by 0
textoff	!by 0
list	!wo 0
clpzl	!by 0
clpsp	!by 0
clpbr	!by 40
clpho	!by 25
mclip	!by 0,0,40,25
full	!by 0,0,40,25
breite	!wo 0
hoehe	!by 25
ymerk	!by 0
used	!by $ff
which	!by 0
fromwhich	!scr "ClipDiskTempUndoVDC2"

reuinit	!by <gbyte,>gbyte,0,$83,7,1,0
	!by 0,$c0,0,0,0,0,$10

; ----------------------------------------- Activity Handler

action	dec adcnt		; count bytes
	bne ld4
	lda #200		; every 200th
	sta adcnt
	ldy offy		; bar at maximum?
	cpy clrmess+1
	bne act0
	jsr clrmess	; yes, clear
act0	ldx offx
	lda filltab,x	; make bar longer
	sta mess,y
	jsr messout	; write bar to output
	dec offx
	bpl ld4
	inc offy
	lda #7
	sta offx
ld4	rts

; ----------------------------------------- 

clrmess   ldx #21		; clear gauge bar
	lda #32
cl0	sta mess,x
	dex
	bpl cl0
	ldy #0		; init counters
	ldx #7	
	sty offy
	stx offx
	rts

messout	ldx #<message	; out
	ldy #>message
	jmp gd_xtxout2

; ----------------------------------------- 

filltab	!by 160,93,103,127,126,124,105,109
message	!scr " Reading  "
mess	!fill 22,32
	!by 0

; ----------------------------------------- Requester

rq3	ldx #$ff
	stx used		; set to $ff after file req
requ	jsr setrplc
	lda list+1
	bne rq1
	ldx sc_screenvek
	ldy sc_screenvek+1
	stx list
	sty list+1
	ldx gr_howmany
	stx howmany
rq1	inc used		; set to 0
	ldx #0
	stx status
	ldx #<bevlst
	ldy #>bevlst
	jsr gd_xmloop	; returns used=$ff
	jsr vw2		; build mainscreen
	
	lda which
	beq rq3
			; leave after bevel:
rq0	sta gr_redisp	; set re-render flag
	lda howmany	; reset quantize table
	sta gr_howmany
	jsr gd_makeqtab
	lda ls_flen	; left file requester w/o file?
	beq rq3		; then go again

	ldx #$ff		; set rebuild flag
	stx used
	inx		; set replace flag
	stx flag4
	jsr srt4		; reset reu table
	ldx #7		; reset text in requester
	ldy #3
rq4	lda fromwhich,x
	sta fromtx4,y
	dex
	dey
	bpl rq4
	jsr setsource	; set load from disk 
	sec		; leave loader
	rts

; --------------------------------------- Event: Bevel

evbevel	ldx #<bevel	; point distributor to bevel
	ldy #>bevel
	jsr setdoit

; --------------------------------------- 

sevmod	inc used		; set to 2
sevrepl	inc used		; set to 1
	ldx used
	dex
	stx which
	bne modify
	lda flag4
	bne rq2

; ----------------------------------------- Open File Requester

filereq	ldx #1
	jsr gd_xload
cn3	lda #3
	sta used
	sec
	rts

; ----------------------------------------- 

modify	lda flag4
	beq filereq
rq2	sta ls_flen	; set fake file len when ram
	jmp gaugeout

; --------------------------------------- Event: Preview

evpreview	lda gd_modswitch
	pha
	jsr ev_prviu
	pla
	sta gd_modswitch
	clc
	rts

; ----------------------------------------- 

setrplc	ldx #0		; point distributor to Load
	stx which
	ldx #<pureraw
	ldy #>pureraw

setdoit	stx doit
	sty doit+1
	sec
	rts

; ----------------------------------------- Palettes

	; Gray  (1):
pgray	!by $00,$03,$03,$03,$03,$07,$07,$07
	!by $07,$07,$0b,$0b,$0b,$0b,$0b,$0f
	; Red   (2):
pred	!by $00,$02,$02,$02,$03,$03,$04,$04
	!by $06,$06,$09,$09,$0d,$0d,$0d,$0f
	; Green (3):
pgreen	!by $00,$03,$03,$07,$07,$07,$0a,$0a
	!by $0a,$0c,$0c,$0c,$0e,$0e,$0e,$0f
	; Blue  (4):
pblue	!by $00,$01,$01,$01,$03,$03,$07,$07
	!by $08,$08,$0b,$0b,$0c,$0c,$0c,$0f

	; Associations:
passoc	!by 1,4,2,1,2,2,2,1,4,2,3,1,4,2,3,1

; ----------------------------------------- Process Bevel

bevel	pha		; get byte from file
	and #15
	sta fbyte
	lda (sc_texttab),y	; get byte from 4bit
	and #15
	sta byte
	jsr quantize	; process right pixel
	sta bbuf
	ldy #0

	pla		; byte from file
	lsr
	lsr
	lsr
	lsr
	sta fbyte
	lda (sc_texttab),y	; byte from 4bit
	lsr
	lsr
	lsr
	lsr
	sta byte
	jsr quantize	; process left pixel
	asl
	asl
	asl
	asl
	ora bbuf		; result in .a
	ldy #0
pureraw	rts

; ----------------------------------------- 

quantize	lda fbyte
	cmp #15		; (white is transparent)
	bne +
	lda byte
	rts

+	sta gr_howmany	; process bevel value:
	jsr gd_makeqtab
	ldx byte		; get byte from 4bit
	lda passoc,x	; get according palette number
	sta fbyte
	lda gr_qtab,x	; change pixel according to bevel:
	tax

	dec fbyte
	beq qz0
	dec fbyte
	beq qz1
	dec fbyte
	beq qz2

qz3	lda pblue,x
	rts

qz2	lda pgreen,x
	rts

qz1	lda pred,x
	rts

qz0	lda pgray,x
	rts

; ----------------------------------------- 

gettab2	sta sc_screentab+1
	lda #0
	tax
	tay
gt0	jsr gd_setpos
	cpx #3
	bne gt0
	stx sc_ho
	jsr gd_trim
	jmp gd_initmove

; ----------------------------------------- Screenlists

gaugelst	!by 0,22,3,34,3,$02,0,0,$80	; REU

; ----------------------------------------- Main Requester

bevlst	!by 0
	!by 6,13,13,11,$81,0,0
	!scr "Bevel@"
from4	!by 8,20,6,3,$cd
	!wo sev4from
fromtx4	!scr "Disk@"
	!by 10,13,13,3,$cb
	!wo sevrepl
	!scr "Load Image@"
	!by 12,13,13,3,$cb
	!wo evbevel
	!scr "Apply Bevel@"
	!by 14,13,13,3,$cb
	!wo evcancel
	!scr "Leave@"
	!by 11,29,11,7,$4d
	!wo evpreview
	!by $c0,8,13,6
	!scr "Source@"
	!by $80

; ----------------------------------------- Image Information Handler

getname	ldx #0
si0	lda ls_lastname,x	; name of loaded picture
	beq si1
	sta nbuf,x
	inx
	cpx #16
	bcc si0
si1	rts

setinfo	jsr setname
	jsr setloader
	jsr setmode
	jmp setdata

setname	lda #0
	ldx #<ls_picname
	ldy #>ls_picname
	bne si3
setloader	lda #17
	ldx #<ls_iloader
	ldy #>ls_iloader
	bne si3
setmode	lda #25
	ldx #<ls_imode
	ldy #>ls_imode
	bne si3
setdata	lda #33
	ldx #<ls_idrive
	ldy #>ls_idrive
si3	stx sc_texttab
	sty sc_texttab+1
	tax
	ldy #0
si4 	lda nbuf,x
	beq si5
	sta (sc_texttab),y
	inx
	iny
	bne si4
si5	rts

nbuf	!fill 16,32	; 16 bytes buffer for filename
	!by 0

	!scr "4BitGod@"
modetx	!scr "320x200@"
datatype	!scr "Color@"

; ----------------------------------------- Re-Build main Screen

vw2	ldx list
	ldy list+1
	jsr gd_screen
	sec
	rts

; ----------------------------------------- Where to load from?

setsource	lda flag4
	pha
	beq ob3
	cmp #3
	bne ob31
ob32	sei
	ldx #$12
	lda #$83
	jsr setvdc
	jsr clrlo
	cli
	ldx #<readvdc
	ldy #>readvdc
	bne ob4
ob31	lda ramtype
	cmp #4
	bcs ob30
	cmp #3
	bne ob32
	lda #$80
	ldx #0
	sta pfvek+1
	stx pfvek
	lda #8
	sta pfbank
	ldx #<readpfox
	ldy #>readpfox
	bne ob4
ob30	cmp #7		; SuperCPU?
	beq ob3		; noch nicht implementiert: Disk
	ldx #<readreu
	ldy #>readreu
	bne ob4
ob3	ldx #<readdisk
	ldy #>readdisk
ob4	stx readvek
	sty readvek+1
	pla
	rts

; ----------------------------------------- Show REU status bar

gaugeout	lda sc_screenvek
	pha
	lda sc_screenvek+1
	pha
	ldx #<gaugelst
	ldy #>gaugelst
	jsr gd_screen
	pla
	sta sc_screenvek+1
	sta gr_redisp
	pla
	sta sc_screenvek
	jmp st0

; ----------------------------------------- Read...

readfile	jmp (readvek)

; ----------------------------------------- from Temp on VDC

readvdc	sei
	ldx #$1f
	stx vdc
tv2	bit vdc
	bpl tv2
	lda vdcdata
	cli
	rts

clrlo	inx
	lda #0
setvdc	stx vdc
tv5	bit vdc
	bpl tv5
	sta vdcdata
	rts

; ----------------------------------------- from Pagefox

readpfox	sei
	sty ymerk
	inc 1
	ldy #0
	lda pfbank
	sta bswitch
	lda (pfvek),y
	sta gbyte
	lda #$ff
	sta bswitch
	inc pfvek
	bne pw0
	inc pfvek+1
pw0	lda pfvek+1
	cmp #$c0
	bne pw1
	lda pfbank
	cmp #10
	beq pw1
	lda #10
	sta pfbank
	lda #$80
	sta pfvek+1
pw1	dec 1
	cli
	ldy ymerk
	lda gbyte
	rts

; ----------------------------------------- from REU

readreu	lda #$91
	jsr gd_reu
	inc rm_werte+2
	bne rr0
	inc rm_werte+3
rr0	iny
	lda gbyte
	rts

; ----------------------------------------- from Disk

readdisk	lda counter
	ora counter+1
	bne getit2
	inc counter
	jsr basin
	cmp #packbyte
	bne getit1
	bit filetype
	bvc getit1
	jsr basin
	sta counter
	beq rb2
	lda #0
	beq rb3
rb2	lda #1
rb3	sta counter+1
	jsr basin
getit1	sta gbyte
getit2	lda counter
	bne rb4
	dec counter+1
rb4	dec counter
	lda gbyte
	rts

; ----------------------------------------- Choose Source

sev4from	lda ls_drive+6
	and #15
	sta ramtype
	tay
	lda banks,y
	sta bank
	cpy #9
	beq ok
next	lda flag4
	cmp #3
	bne srt0
	lda #$ff
	sta flag4
srt0	inc flag4
	beq srt1
	lda flag4
	cmp #1
	beq srt2
	cmp #3
	beq srt8
	lda rm_ramundo
	and #1
	beq next
srt7	ldx #$10
	lda #0
	jsr srt3
	ldx #15
	bne text4

srt3	stx reuinit+3
	sta reuinit+4
	ldx #6
	!by $2c
srt4	ldx #13
	ldy #6
srt5	lda reuinit,x
	sta rm_werte,y
	dex
	dey
	bpl srt5
ok	clc
	rts

; ----------------------------------------- 

srt2	lda rm_tmpsaved
	and #1
next1	beq next
	ldx #$83
	lda bank
	jsr srt3
	ldx #11
	bne text4

srt1	jsr srt4
	ldx #7
text4	stx textoff
	ldx #0		; check for being in Modify Mode 
	lda (doit,x)
	cmp #$60		; $60 is code for RTS
	bne ok		; if .a=$60: we are in Replace Mode, leave 
	ldx textoff
	ldy #3
srt6	lda fromwhich,x
	sta fromtx4,y
	dex
	dey
	bpl srt6
	lda #<from4
	sta sc_screentab
	lda #>from4
srt9	jsr gettab2
	ldy #6
	jmp gd_xtxout1

srt8	lda rm_tmpsaved
	and #2
	beq next1
	ldx #19
	bne text4

; ----------------------------------------- Clipdaten einlesen

jerror2	jmp error
getfclip	jsr onebyte	; Clipzeile holen
	bne jerror2	; bei Fehler: Abbruch
	sta clpzl
	jsr onebyte	; Clipspalte holen
	bne jerror2
	sta clpsp
	jsr onebyte	; Clipbreite holen
	bne jerror2
	sta clpbr
	jsr onebyte	; Cliphöhe holen
	bne jerror2
	sta clpho
	rts

; ----------------------------------------- Full setzen

setfull	lda filetype	; echter Clip?
	ldx full+2	; (bei Full: Breite 40)
	and #2
	beq gm9		; nein
	ldx brmerk	; ja, Clipbreite holen
gm9  	ldy #3
gm0	lda full,y
	sta mclip,y
	sta clpzl,y
	dey
	bpl gm0
	jsr setclip
	lda full+3	; Höhe 25
	sta hoehe
	txa		; Breite:
	sta rrand		; rechter Rand 40 oder Clipbreite
	jmp gbh2		; Breite und Skip

; ---------------------------------------- Startadresse des Clips

setclip	lda #$40		; $4000
	sta sc_texttab+1
	ldy #$00
	sty sc_texttab

stcl	lda mclip		; plus Clipzeile * 1280
	beq scp1
	sta clpzl
scp4	clc
	lda sc_texttab+1
	adc #5
	sta sc_texttab+1
	dec clpzl
	bne scp4

scp1	lda mclip+1	; plus Clipspalte * 32
	beq scp5
	sta clpsp
scp6	clc
	lda sc_texttab
	adc #$20
	sta sc_texttab
	bcc scp7
	inc sc_texttab+1
scp7	dec clpsp
	bne scp6		; ist Startadresse 

scp5	lda sc_texttab
	ldy sc_texttab+1
	sta dst
	sty dst+1
	rts 

; ----------------------------------------- Filebreite holen

getbr	ldy #0
	sty breite
	sty breite+1
gbh0	clc		; Breite * 32
	lda breite
	adc #$20
	sta breite
	bcc gbh1
	inc breite+1
gbh1	dex
	bne gbh0		; ist Zähler für Breite 
	rts

; ----------------------------------------- Wahre Breite des Clips

gbh2	tax		; mal 32
	jsr getbr
	lda breite
	sta bbreite	; und merken
	lda breite+1
	sta bbreite+1

	ldx brmerk	; Breite wieder zurück
	rts

; ----------------------------------------- 

modend	!eof
