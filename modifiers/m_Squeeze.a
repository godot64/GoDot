
	!src "..\godotlib.lib"
	*= $c000
	!ct pet
;	!sl "labels.txt"

; ----------------------------------------- 
;
;  mod.Squeeze
;   Module to scale down a screen to the size of the clip
;   with the option to keep the aspect ratio of a C64 screen
;
;  1.00, 10.05.18, first release (derived from mod.Squeeze2Clip)
;
; ----------------------------------------- 

; ----------------------------------------- Equates

	pport		= $01
	int		= $14

	ymrk		= $30
	adcnt		= $31
	dstcnt		= $33
	src		= $35
	dst		= $37
	colnr		= $39
	linenr		= $39
	blcnt		= $3b
	sum		= $3c
	bbuf		= $3e
	ybufstart		= $3f
	sbak		= $3f
	bufend		= $41
	tab		= $41
	null		= $43
	which		= $44
	txtlen		= $45
	xmrk		= $46

	sprptr		= $07f8
	sysvars		= sy_global
	spr255		= $3fc0

	xtab0		= $c800
	xbuf0		= $ca00
	xbuf1		= $cc00
	ytab0		= xtab0
	ybuf0		= xbuf0
	ybuf1		= xbuf1

	setarg		= $ba8c	; in .a/.y
	setfac		= $bba2	; in .a/.y
	arg2fac		= $bbfc
	fac2arg		= $bc0f
	facpl05		= $b849
	facceil		= $bc1b
	argmulfac		= $ba2b
	argdivfac		= $bb12
	conisfac		= $bc5b	; const in .a/.y
	condivfac		= $bb0f	; constant in .a/.y (uses setarg)
	conmulfac		= $ba28	; dito
	intfac		= $bc49	; $62: hi, $63: lo, .x: #$90, .c=1
	facint		= $b7fb	; result in (int)
	facasc		= $bddf	; result in ls_nambuf

	spr2x		= $d004
	spr2y		= spr2x+1
	msbx		= $d010
	spren		= $d015
	sprxe		= $d01d
	border		= $d020
	sprcol2		= $d029

; -------------------------------------------------- Header

	jmp start
	!by $20
	!wo 0
	!wo modend
	!wo 0
	!tx "Squeeze /w Ratio"
	!tx "1.00"
	!tx "10.05.18"
	!tx "A.Dettke        "

; -------------------------------------------------- Main Program

start	jsr savesvars
	jsr makechr
	ldx #<sqzlst
	ldy #>sqzlst
	jsr gd_screen
	jsr setdata
	jmp gd_eloop

; ----------------------------------------- Event: Execute Modifier

evexec	jsr vres		; execute
	jsr hres
	jsr clearad	; and leave module

; ----------------------------------------- Event: Leave Modifier

evleave	jsr restsvars
	sec		; leave
	rts

; ----------------------------------------- Event: Adjust Width

evadjx	inc pport
-	jsr multiply
	lda imrk
	tax
	clc
	adc sc_lastclpsp
	cmp #41		; result too wide?
	bcc +
	jmp graphon	; yes, blink border
+	stx sc_lastclpbr
	lda #1
	jsr settoff
	ldx #4
	jsr di0
	jsr lmultiply
	lda imrk
	sta width
	lda imrk+1
	sta width+1
	lda #2
	jsr settoff
	ldx #2
	jsr di0
	jmp shresult

; ----------------------------------------- Event: Adjust Width

evadjy	inc pport
	jsr divide
	lda imrk
	tax
	clc
	adc sc_lastclpzl
	cmp #26		; result too high?
	bcc +
	jmp graphon	; yes, blink border
+	stx sc_lastclpho
	lda #1
	jsr settoff
	ldx #8
	jsr di0
	jsr ldivide
	lda imrk
	sta height
	lda imrk+1
	sta height+1
	lda #2
	jsr settoff
	ldx #6
	jsr di0
	jmp shresult

; ----------------------------------------- Event: Show Preview

evpreview	lda gd_modswitch
	pha
	jsr ev_prviu
	pla
	sta gd_modswitch
	rts

; ----------------------------------------- Save System Variables

savesvars	ldy #9		; area affected by float routines
-	lda ls_lines,y
	sta sysvars,y
	dey
	bpl -
	rts

; ----------------------------------------- Restore System Variables

restsvars	ldy #9
-	lda sysvars,y
	sta ls_lines,y
	dey
	bpl -
	rts

; ----------------------------------------- 

setdata	inc pport

	lda #1
	jsr settoff
	
	jsr wid2fac	; clip width (in Kacheln) nach fac
	ldx #4		; Ergebis eintragen und ausgeben
	jsr di0		; .x=0

	jsr hgt2fac	; clip height (in Kacheln) nach fac
	ldx #8		; Ergebis eintragen und ausgeben
	jsr di0		; .x=0

	lda #2		; das Gleiche in Pixel (Clip-Breite)
	jsr settoff
	clc
	lda sc_lastclpbr
	asl
	asl
	asl
	bcc +
	inx
+	sta width		; Ergebnis als Integer merken
	stx width+1
	jsr any2fac
	ldx #2		; ausgeben
	jsr di0		; .x=0

	lda sc_lastclpho	; und ebenso Clip-Höhe
	asl
	asl
	asl
	sta height	; als Integer merken
	stx height+1
	jsr any2fac
	ldx #6		; ausgeben
	jsr di0		; .x=0

shresult	jsr getwid	; result will be distorted?
	jsr fac2arg
	jsr gethgt
	jsr argdivfac
	lda #<fratio	; Breite:Höhe=8:5? (Richtiger Aspekt?)
	ldy #>fratio
	jsr conisfac
	beq +
	ldx #2		; nein
	!by $2c
+	ldx #5		; ja
	ldy #2
-	lda distort,x	; eintragen...
	sta resgad+7,y
	dex
	dey
	bpl -
	stx xmrk

	jsr cnvwdt	; 320x256/width =
	jsr fac2arg
	jsr getwid
	jsr divit
	lda int
	sta xstep		; xstep
	lda int+1
	sta xstep+1
	jsr cnvhgt	; 200x256/height =
	jsr fac2arg
	jsr gethgt
	jsr divit
	lda int
	sta ystep		; ystep
	lda int+1
	sta ystep+1

	dec pport

	jsr settxt	; ..und für Ausgabe vorbereiten
	ldx xmrk
	bmi +		; pos: Aspekt stimmt
	lda #14		; Zeile mit Adjust-Aufforderung löschen
	ldx #13
	tay
	jsr gd_setpar	; !! mind values at adjtx !!
	jsr gd_clrline
+	ldy #0		; Ergebnis des Checks ausgeben
	sty ymrk
	jmp textout

; ----------------------------------------- 

di0	stx ymrk		; Index auf Zahl merken
	jsr facasc	; convert fac to digits
	jsr di1		; Ziffern holen
	ldy ymrk		; Index zurück
	jsr movetx	; Ziffern in die Screenlist schreiben
	jsr textout	; und ausgeben
	clc		; im Modul bleiben
	rts

; ----------------------------------------- Make Digits

di1	ldy #9		; Ziffer-Ende suchen
di2	dey
	bmi +		; keins? dann nichts tun
	lda sy_numbers,y
	bne di2

	ldx #0		; Ziffernpuffer löschen
	lda #32
-	sta text,x
	inx
	cpx txtlen
	bne -

	dey
di3	lda sy_numbers,y	; und neue Ziffern eintragen
	beq +		; Doppel-Null: Fehler, nichts tun
	sta text,x
	dex
	dey
	bpl di3
+	rts

; ----------------------------------------- Digits to Screenlist

movetx	jsr settxt
	ldx txtlen
	ldy toff
-	lda text,x
	sta (sc_screentab),y
	dey
	dex
	bpl -
	rts
	
settoff	clc
	sta txtlen
	adc #7
	sta toff
	rts

gethgt	lda height
	ldx height+1
	jmp any2fac

getwid	lda width
	ldx width+1
	jmp any2fac

; -------------------------------------------------- First Pass: vertically

vres	lda sc_lastclpho	; clip height less 25 rows?
	cmp #25
	bcc vstart0	; yes, squeeze
	jmp graphon	; else blink border

vstart0	lda sc_lastclpzl	; compute start line (0-192)
	asl
	asl
	asl
	sta ybufstart
	clc
	lda height	; get height in lines (8-192)
	adc ybufstart
	sta bufend

	lda #0		; clear sum
	sta sum
	sta sum+1

	ldy ybufstart	; write scaling values to buffer 
vtabl	sta ytab0,y	; (first time: clear buffer)
	lda sum
	clc
	adc ystep
	sta sum
	lda sum+1
	adc ystep+1
	sta sum+1
	iny
	cpy bufend
	bne vtabl

	lda #8		; init Activity Display
	jsr initad

	ldy #0		; clear target buffer
	tya
vclrlp	sta ybuf1,y
	iny
	bne vclrlp

; -------------------------------------------------- Shrink

	lda #$00		; clear column 
	sta colnr
	sta colnr+1

vloop00	lda colnr+1	; get column
	lsr		; divide by 2 
	sta src+1
	lda colnr		; odd or even?
	ror
	bcs odd0
	ldx #$0f		; if odd: right pixel
	!by $2c
odd0	ldx #$f0		; if even: left pixel
	stx which

	tax		; compute address in 4Bit memory
	and #$03
	sta src
	txa
	and #$fc
	asl
	rol src+1
	asl
	rol src+1
	asl
	rol src+1
	ora src
	sta src
	lda src+1
	ora #$40
	sta src+1

	ldx #0		; now squeeze, part 1
	stx null		; clear no-op-flag

vloop0	ldy #0		; get value
vloop1	lda (src),y
	bit which		; odd or even?
	bvs odd1
	lsr		; even: shift down left pixel
	lsr
	lsr
	lsr
odd1	and #$0f		; odd: get right pixel
	sta ybuf0,x	; store value
	beq nuls0		; branch if $00
	sta null		; if NULL is > $00 there's at least 1 value being squeezed
nuls0	inx		; go to pixel below
	iny
	iny
	iny
	iny
	cpy #32
	bcc vloop1	; until bottom of tile

	lda src+1		; go to next row of tiles
	clc
	adc #>(1280)
	sta src+1
	cmp #$bd		; until end of 4Bit memory
	bcc vloop0	; thus scanning 1 vertical band

	lda null		; anything to squeeze?
	beq nextcol	; no, proceed to next band

	ldy ybufstart	; yes, get pointers to source
vsql	ldx ytab0,y
	lda ybuf0,x
	sta ybuf1,y
	iny
	cpy bufend
	bne vsql

	lda colnr+1	; then write 1 squeezed band
	lsr
	sta dst+1
	lda colnr		; determine which pixel (left or right)
	ror
	bcs odd2
	ldx #$0f		; right
	!by $2c
odd2	ldx #$f0		; left
	stx which

	tax		; compute address in 4Bit memory
	and #$03
	sta dst
	txa
	and #$fc
	asl
	rol dst+1
	asl
	rol dst+1
	asl
	rol dst+1
	ora dst
	sta dst
	lda dst+1
	ora #$40
	sta dst+1

	ldx #0		; squeeze, part 2
vloop2	ldy #0		; get band from part 1
vloop3	lda ybuf1,x
	bit which
	bvs odd3
	asl		; left
	asl
	asl
	asl
odd3	sta bbuf		; right
	lda (dst),y
	and which
	ora bbuf
	sta (dst),y
	inx
	iny
	iny
	iny
	iny
	cpy #32
	bcc vloop3	; until bottom of tile

	lda dst+1		; next tile row below
	clc
	adc #>(1280)
	sta dst+1
	cmp #$bd
	bcc vloop2	; until end of 4Bit memory

nextcol	inc colnr		; next band
	bne vskip0
	inc colnr+1
vskip0	lda colnr		; is #320 (right limit)?
	cmp #<(320)
	bne vskip1
	lda colnr+1
	bne vok		; yes, finished

vskip1	dec adcnt		; Activity Display
	bne vadskp
	inc spr2y
	inc spr2y+2
	lda #8
	sta adcnt
vadskp	jmp vloop00	; start over
vok	rts

; -------------------------------------------------- Second Pass: horizontally

hres	lda sc_lastclpbr	; clip width less than 40 tiles?
	cmp #40
	bcc hstart0	; yes, squeeze
	jmp graphon	; else blink border

hstart0	lda #0		; clear sum
	sta sum
	sta sum+1
	sta sbak

	sta dstcnt+1	; init start values
	lda #>xtab0
	sta tabstart+1
	lda #>xbuf1
	sta bufstart+1

	lda sc_lastclpsp
	asl
	asl
	asl
	sta tabstart
	sta bufstart
	bcc xskip0
	inc tabstart+1
	inc bufstart+1

xskip0	lda width		; init step values
	sta dstcnt
	lda width+1
	sta dstcnt+1

xl01	lda tabstart
	ldx tabstart+1
	sta tab
	stx tab+1

	ldy #0
	lda dstcnt+1	; width > 31?
	beq xloop1
	lda dstcnt	; v1.03
	beq xloop1	; v1.03
	
xloop0	lda sum+1		; yes, create table accordingly
	sec
	sbc sbak
	sta (tab),y
	lda sum
	clc
	adc xstep
	sta sum
	lda sum+1
	sta sbak
	adc xstep+1
	sta sum+1
	iny
	bne xloop0
	inc tab+1

xloop1	lda sum+1		; table at width < 32
	sec
	sbc sbak
	sta (tab),y
	lda sum
	clc
	adc xstep
	sta sum
	lda sum+1
	sta sbak
	adc xstep+1
	sta sum+1
	iny
	cpy dstcnt
	bne xloop1

	lda #5		; init Activity Display
	jsr initad

	ldy #0		; clear buffer
	tya
hclrlp	sta xbuf1,y
	sta xbuf1+256,y
	iny
	bne hclrlp

	lda #$00		; get 1 line
	sta linenr
hloop00	lda linenr	; compute address in 4Bit memory
	pha
	lsr
	lsr
	lsr
	tax
	pla
	and #$07
	asl
	asl
	sta dst
	lda line8,x
	sta dst+1

	lda #<xbuf0	; squeeze, part 3
	ldx #>xbuf0
	sta src
	stx src+1

	ldx #0		; clear no-op-flag
	stx null
	lda #40		; scan 40 tiles
	sta blcnt
hloop0	ldy #0
hloop1	lda (dst),y
	beq nuls1
	sta null		; set flag if value > $00
nuls1	pha
	lsr
	lsr
	lsr
	lsr
	sta (src,x)	; left pixel
	inc src
	bne hskip0
	inc src+1
hskip0	pla
	and #$0f
	sta (src,x)	; right pixel
	inc src
	bne hskip1
	inc src+1
hskip1	iny
	cpy #4
	bne hloop1	; until 8 pixels

	lda dst		; next tile to the right
	clc
	adc #32
	sta dst
	bcc hskip2
	inc dst+1
hskip2	dec blcnt		; until 40 tiles
	bne hloop0

	lda null		; anything to squeeze?
	bne xdoit
	jmp nextline	; no, proceed with next line

xdoit	lda #<xbuf0	; squeeze in two steps...
	ldx #>xbuf0
	sta src
	stx src+1

	lda bufstart
	ldx bufstart+1
	sta dst
	stx dst+1

	lda tabstart
	ldx tabstart+1
	sta tab
	stx tab+1

	ldx #0
	ldy #0
	lda dstcnt+1
	beq xloop3
	lda dstcnt	; v1.03
	beq xloop3	; v1.03
	
xloop2	lda (tab),y	; ...width > 31
	clc
	adc src
	sta src
	bcc xskip1
	inc src+1
xskip1	lda (src,x)
	sta (dst),y
	iny
	bne xloop2
	inc tab+1
	inc dst+1
	
xloop3	lda (tab),y	;  ...width < 32
	clc
	adc src
	sta src
	bcc xskip2
	inc src+1
xskip2	lda (src,x)
	sta (dst),y
	iny
	cpy dstcnt
	bne xloop3

	lda linenr	; write line
	pha
	lsr		; compute address in 4Bit memory
	lsr
	lsr
	tax
	pla
	and #$07
	asl
	asl
	sta dst
	lda line8,x
	sta dst+1

	lda #<xbuf1	; squeeze, part 4
	ldx #>xbuf1
	sta src
	stx src+1
	ldx #0
	lda #40		; 40 tiles
	sta blcnt
hloop2	ldy #0
hloop3	lda (src,x)	; get left pixel
	asl
	asl
	asl
	asl
	inc src
	bne hskip3
	inc src+1
hskip3	ora (src,x)	; combine with right pixel
	inc src
	bne hskip4
	inc src+1
hskip4	sta (dst),y	; store
	iny
	cpy #4
	bne hloop3	; until 8 pixels

	lda dst		; next tile
	clc
	adc #32
	sta dst
	bcc hskip5
	inc dst+1
hskip5	dec blcnt		; until 40 tiles
	bne hloop2

nextline	inc linenr	; next line
	lda linenr
	cmp #200
	beq hok		; until 200 lines, then finished

	dec adcnt		; Activity Display
	bne adskp
	inc spr2y
	inc spr2y+2
	lda #5
	sta adcnt
adskp	jmp hloop00	; start over
hok	rts

; ----------------------------------------- Text Output Handler

tabigad	!wo resgad	; 0
	!wo xgad		; 2
	!wo widgad	; 4
	!wo ygad		; 6
	!wo hgtgad	; 8

settxt	lda #<tabigad
	sta sc_texttab
	lda #>tabigad
	sta sc_texttab+1

settx2	lda (sc_texttab),y	; set gadget parameters (where to output)
	sta sc_screentab
	iny
	lda (sc_texttab),y
	sta sc_screentab+1
	rts

gettab	lda #0
	tax
	tay
gt0	jsr gd_setpos
	cpx #4
	bne gt0
	jsr gd_trim
	jmp gd_initmove

; ----------------------------------------- Output Text

textout	ldy ymrk
	jsr settx2
	jsr gettab
	ldy #6		; offset to gadget text
	jmp gd_xtxout1	; show text

; ----------------------------------------- Divide: width/1.6

ldivide	jsr getwid
	jmp dv0

divide	jsr wid2fac	; breite holen
dv0	jsr fac2arg	; nach arg
	jsr cnvrio	; aspekt holen
	jsr divit
	jsr intmerk
	jmp int2fac	; nach float

divit	jsr argdivfac	; dividieren
	jsr facpl05	; ergebnis runden
	jsr facceil
	jmp facint	; nach integer

; ----------------------------------------- Multiply: height*1.6

lmultiply	jsr gethgt
	jmp mp0

multiply	jsr hgt2fac	; höhe holen
mp0	jsr fac2arg	; nach arg
	jsr cnvrio	; aspekt holen
	jsr argmulfac	; multiplizieren mit 1.6
	jsr facpl05	; ergebnis runden
	jsr facceil
	jsr facint	; nach integer (in int)
	jsr intmerk
	jmp int2fac	; nach float

; ----------------------------------------- Get Float Values

cnvrio	lda #<fratio	; ratio (1.6) nach fac
	ldy #>fratio
	bne +

cnvhgt	lda #<fheight	; 200x256
	ldy #>fheight
	bne +

cnvwdt	lda #<fwidth	; 320x256
	ldy #>fwidth

+	jmp setfac

; ----------------------------------------- Get Integer Values

any2fac	stx int+1
	sta int

int2fac	lda int+1
	ldx int
	jmp cnvwa
	
wid2fac	lda #0
	ldx sc_lastclpbr
	jmp cnvwa

hgt2fac	lda #0
	ldx sc_lastclpho

cnvwa	sta $62		; hi
	stx $63		; lo
	ldx #$90
	sec
	jmp intfac

intmerk	lda int
	sta imrk
	lda int+1
	sta imrk+1
	rts

; -------------------------------------------------- Activity Display

clearad	lda spren		; activity bar off (leave mouse on)
	and #243
	sta spren
	sta gr_redisp	; re-render
	lda msbx
	and #243
	sta msbx
	rts

initad	sta adcnt
	ldy #60
	lda #0
adl0	sta spr255+3,y
	dey
	bpl adl0
	sty spr255
	sty spr255+1
	sty spr255+2
	lda #15
	sta sprcol2
	sta sprcol2+1
	lda sprxe
	ora #12
	sta sprxe
	lda msbx
	ora #12
	sta msbx
	lda #8
	sta spr2x
	lda #32
	sta spr2x+2

	lda #146
	sta spr2y
	sta spr2y+2
	sty sprptr+2
	sty sprptr+3
	lda spren
	ora #12
	sta spren
	rts

; -------------------------------------------------- Blink Border

graphon	lda #$36
	sta pport
	lda border
	pha
	lda #2
	sta border
	ldx #$40
	jsr gd_dl2
	pla
	sta border
stay	clc
	rts

; --------------------------- Kringel definieren

makechr	ldx #7
-	lda chschr,x
	sta sc_undochar,x
	dex
	bpl -
	rts

; -------------------------------------------------- Data

chschr	!by $00,$0e,$06,$0a,$50,$60,$70,$00

line8	!by $40,$45,$4a,$4f,$54
	!by $59,$5e,$63,$68,$6d
	!by $72,$77,$7c,$81,$86
	!by $8b,$90,$95,$9a,$9f
	!by $a4,$a9,$ae,$b3,$b8

; -------------------------------------------------- 
; ystep = 200x256/blockzeile*8 (0..25)
; 200x256: 51200 ($c800 = 90 48 00 00 00)
; --------------------------------------------------
; xstep = 320x256/blockspalte*8 (0..39)
; 320x256: 81920 ($014000 = 91 20 00 00 00)

xstep	!wo 0
ystep	!wo 0
tabstart	!wo 0
bufstart	!wo 0

; ----------------------------------------- 

fwidth	!by $91,$20,$00,$00,$00	; float: 320x256=81920
fheight	!by $90,$48,$00,$00,$00	; float: 200x256=51200
fratio	!by $81,$4c,$cc,$cc,$cd	; float: 1.6
width	!wo 0
height	!wo 0
imrk	!wo 0
distort	!scr "   not"
text	!fill 5,32
toff	!by 11

; -------------------------------------------------- Screenlist

sqzlst	!by 0
	!by 3,12,16,19,$81
	!wo 0
	!scr "Squeeze@"

widgad	!by 7,16,4,3,$a0
	!wo 0
	!scr "..@"

hgtgad	!by 7,23,4,3,$a0
	!wo 0
	!scr "..@"

resgad	!by 11,13,5,3,$a0
	!wo 0
	!scr "not@"

xgad	!by 15,14,5,3,$a0
	!wo 0
	!scr "...@"

	!by 15,19,3,3,$c0	; adjust x
	!wo evadjx
	!by 223,0

	!by 11,29,11,7,$4d
	!wo evpreview

	!by 17,22,6,3,$cf
	!wo evexec
	!scr "Exec@"

ygad	!by 18,14,5,3,$a0
	!wo 0
	!scr "...@"

	!by 18,19,3,3,$c0	; adjust y
	!wo evadjy
	!by 223,0

	!by 19,22,6,3,$ce
	!wo evleave
	!scr "Exit@"

	!by $c0,5,12,13
	!scr "Current Clip:@"
	!by $c0,7,12,3
	!scr "Wid@"
	!by $c0,7,19,3
	!scr "Hgt@"
	!by $c0,9,12,12
	!scr "Results are:@"
	!by $c0,11,17,9
	!scr "distorted@"
	!by $c0,13,12,14
adjtx	!scr "Adjust X or Y:@"
	!by $c0,15,12,1
	!scr "X@"
	!by $c0,18,12,1
	!scr "Y@"

	!by $80

; -------------------------------------------------- 

modend	!eof
