
	!src "godotlib.lib"
	*= $c000
	!ct pet
;	!sl "labels.txt"

; ----------------------------------------- 
;
;  mod.IFLI-Heatmap
;   Module to provide a skeleton for other modules
;
;  1.00, 30.01.22, first release
;
; ----------------------------------------- 

; ----------------------------------------- Equates

	adcnt	= $30 	; activity counter
	src	= $31	; /$32
	dst	= $33	; /$34
	lcnt	= $35
	bcnt	= $36
	byte1	= $37
	byte2	= $38

	sprptr	= $07f8
	spr255	= $3fc0

	spr2x	= $d004
	spr2y	= $d005
	msbx	= $d010
	spren	= $d015
	sprxe	= $d01d
	border	= $d020
	sprcol2	= $d029

; ----------------------------------------- Header

header	jmp start
	!by $20
	!by 0
	!by 0
	!wo modend
	!wo 0
	!tx "Show IFLI diffs "
	!tx "1.00"
	!tx "30.01.22"
	!tx "A.Dettke        "

; ----------------------------------------- Main

start	jsr check4reu	; reu present?
	bne noreu

	lda gd_modswitch
	sta modswitch
	lda gr_redisp
	sta redisp
	lda #9		; Funktion "Undo in die REU" setzen
	sta getundo+1
	jsr doundo	; automatisches Undo ausführen
	jsr gd_spron

	jsr render

	lda #8		; Funktion "Undo aus der REU" setzen
	sta getundo+1
	jsr doundo	; und ausführen

	jsr gd_spron
	lda redisp
	sta gr_redisp
	lda modswitch
	sta gd_modswitch
	clc
	rts
	

; ----------------------------------------- No REU

noreu	ldx #<warnlst
	ldy #>warnlst
	jmp gd_xmloop

; ----------------------------------------------------- 

warnlst	!by 0
	!by 8,9,21,9,$81
	!wo 0
	!scr "MESSAGE@"
	!by 14,23,7,3,$cd
	!wo canc
	!scr "Leave@"
	!by $c0,10,10,16
	!scr "No REU detected.@"
	!by $c0,12,11,15
	!scr "Mod won't work.@"
	!by $80
	
; ----------------------------------------- Render Image Diffs

render	jsr initad

	lda #<sy_4bit	; .a=0
	sta src
	sta lcnt
	sta bcnt
	tay
	lda #>sy_4bit
	sta src+1

-	lda (src),y	; get 2 pixels
	tax
	lsr
	lsr
	lsr
	lsr
	sta byte1		; left one
	txa
	and #15
	sta byte2		; right one
	ldx byte1
	cmp byte1		; which is larger?
	bcc +
	beq +
	sta byte1		; if byte2: exchange
	stx byte2
+	lda byte1
	sec
	sbc byte2
	tax
	lda dnibs,x
	sta (src),y
	iny
	bne -
	jsr adinc
	inc src+1
	lda src+1
	cmp #>sy_bigbuffer
	bcc -

	sta gr_redisp
	jsr clearad
	jmp ev_display

; ---------------------------------------------- DoUndo

doundo	lda #<undo	; eigentliche Routine verschieben
	ldx #>undo	; (weil das Modul ausgeblendet wird)
	sta ls_vekta8
	stx ls_vekta8+1
	ldy #adinc-undo-1
sloop	lda (ls_vekta8),y
	sta sy_global,y	; nach GLOBAL
	dey
	bpl sloop
	jmp sy_global	; und dann ausführen

undo 	jsr gd_swapd	; Ram einblenden
	ldx #10		; FirstInit
	jsr rm_ramvec

	ldx #6		; Parameter setzen
	lda #0
md0	sta rm_werte,x	; zuerst löschen
	dex
	bpl md0
	lda #>sy_4bit	; 4Bit-Bereich im C64
	sta rm_werte+1
	lda #$10		; nach Undo4Bit im Ram
	sta rm_werte+3	; ($8d für Undo Rendered)
	lda #$7d		; 32000 Bytes
	sta rm_werte+6

	lda #1		; Flag für 4Bit-Undo setzen
	sta rm_nextentry	; (#2 für Undo Rendered!)

getundo	ldx #9		; und DoUndo
	jsr rm_ramvec
	ldx #1		; danach ForceOff (Ram ausblenden)
	jsr rm_ramvec	
	jmp gd_sproff	; und Sprite wieder aus, zurück

; ------------------------------------------------ Activity

adinc	dec adcnt		; advance after adcnt passes
	bne +
	inc spr2y
	inc spr2y+2
	jmp setadcnt	; and reset adcnt

; ------------------------------------------------ Finish Activity

clearad	lda spren		; progress bar off
	and #$f3
	sta spren
	lda msbx
	and #$f3
	sta msbx
canc	sec 		; finished
+	rts 

; ------------------------------------------------ Init Activity

initad	ldy #60		; prepare spriteblock 255
	lda #0
-	sta spr255+3,y
	dey 
	bpl -
	sty spr255	; thin line
	sty spr255+1
	sty spr255+2
	lda #15		; light gray
	sta sprcol2
	sta sprcol2+1
	lda sprxe		; x-expanded
	ora #$0c
	sta sprxe

	lda msbx		; x is beyond 255
	ora #$0c
	sta msbx
	lda #8		; so x is 8 (plus 256)
	sta spr2x
	lda #$20
	sta spr2x+2
	lda #$92		; y is 146
	sta spr2y		; (in Image Information window)
	sta spr2y+2

	sty sprptr+2	; use sprite 255
	sty sprptr+3
	lda spren
	ora #$0c		; activate bar
	sta spren

setadcnt	lda #3		; init counter to 5 (times 40 = 120 pages of 125)
	sta adcnt
	rts

; -------------------------------------- Check for REU

check4reu	lda ls_ramdrive	; welcher Ramdrive? (detected by system)
	and #15
	ldx #6
	cmp #8		; 1700
	beq graphon	; too small
	cmp #4		; 1764
	bne st2
	cpy #2		; MODs in bank 2?
	bcs graphon	; too small
	ldx #2
	bne st7
st2	cmp #5		; 1750
	bne graphon
	cpy #6		; MODs in bank 6?
	bcs graphon	; too small
st7	stx bank

	lda rm_ramvec	; Device eingebunden?
	cmp #$4c		; equal, wenn ja
	rts

; ----------------------------------------------------- Blink the Border

graphon	ldy #2		; red
	lda border	; save border color
	pha
	sty border	; set new color (in .y, here: 2 for red)
	ldx #$40
	jsr gd_dl2	; delay (.x=0)
	pla
	sta border	; reset old border color
	stx sy_tbuffer	; clear key strokes
stay	clc
	rts

; ----------------------------------------- Data

bank	!by 0				; used by CHECK4REU
redisp	!by 0
modswitch	!by 0
dnibs	!by $00,$11,$22,$33,$44,$55,$66,$77
	!by $88,$99,$aa,$bb,$cc,$dd,$ee,$ff

; ----------------------------------------- 

modend	!eof
