
	!src "godotlib.lib"	; Label-Library einbinden
	*= $c000		; generelle Startadresse für alle Module
	!ct pet		; Texte werden in PETSCII assembliert
;	!sl "labels.txt"

; -----------------------------------------
;
; svr.VDClowres
;
; 1.00, 14.01.24, first release
;
;       creates 8000 bytes for a 160x100 pixel
;       cga-style vdc image (like Basic8 mode 1)
;
; -----------------------------------------

; ----------------------------------------- Label-Definitionen

	pport	= $01		; Systemlabels

	cnt0	= $30
	cnt1	= $31
	cnt2	= $32
	cnt3	= $33
	adcnt	= $34		; Zähler für activity
	ymerk	= $35
	byte	= $36
	getdata	= $37		; /38

	offx	= ls_adrmisc	; gauge counters
	offy	= offx+1

; ----------------------------------------- Header

 	jmp start			; Jedes Modul beginnt hiermit

	!by $40 			; $80=Lader, $40=Saver, $20=Modifier, $10=Device
	!by 0			; Own-Requester-Flag (nur!) für Lader (4 = eigener Req)
	!by 0			; Dirty Flag (1 = dirty, 0 = clean)
	!wo modend		; Endadresse+1 des Moduls
	!wo 0			; reserviert
	!tx "VDC lowres Saver"	; Beschreibung (16 Zeichen)
	!tx "1.00"		; Versionsnummer (4 Zeichen)
	!tx "14.01.24"		; Datum (8 Zeichen tt.mm.jj)
	!tx "A.Dettke        "	; Autor (16 Zeichen)

; ----------------------------------------- 

; ----------------------------------------- 
; ----------------------------------------- These next lines _mandatory_ for savers!
; ----------------------------------------- 

start	ldx gr_nr		; Funktionsnummer testen:
	dex
	bne saver		; Null, dann eigentlichen Saver aufrufen

	jmp initinp	; eins, dann "Input" ausführen (in INPUT.INC)

; -----------------------------------------
; -----------------------------------------
; ----------------------------------------- 

; ----------------------------------------- Main

saver

st11	lda gd_modswitch	; Memory Management
	pha

	jsr gd_sproff
	lda ls_flen	; Filename wurde vom Filerequester übergeben?
	beq st1		; nein (dann Cancel)

	sta wflen		; sonst: Länge sichern
	jsr addsig	; Namenskürzel anhängen ("vdc")
	jsr wopen		; Datei zum Schreiben öffnen
	bne st2		; wenn Diskettenfehler: Ende

	jsr getname	; Filenamen für Image Information sichern
	ldx #12		; OPEN #12, out
	jsr ckout
	jsr gd_clrms	; Fortschrittsbalken und Statusausgaben vorbereiten
	ldx #0		; Anzeigetext #1 (Offset .x=0) eintragen
	jsr tcopy
	iny		; .y=1
	sty adcnt		; Activity (Fortschrittsbalken) starten (.y=1)

	jsr write		; jetzt Bild speichern

st2	jsr clrch		; danach Bus freigeben
	lda #12		; Datei #12 schließen
	jsr close
	jsr err9		; Floppystatus zeigen (nur sehr kurz)
	bne st1

	jsr setname	; nur wenn fehlerfrei: Image Information aufbereiten

st1	pla		; dann Saver abwickeln: Memory Management
	sta gd_modswitch

st12	jsr gd_spron	; Mauszeiger wieder an
	sec		; Leave-Flag setzen
	rts		; fertig, Saver verlassen


; ----------------------------------------- 
; ----------------------------------------- Input Routines (This next line _mandatory_ for savers!)
; ----------------------------------------- 

	!src "input.inc"

; ----------------------------------------- 
; ----------------------------------------- Write File
; ----------------------------------------- 

write	lda #$80		; start address: $3e80 (in VDC)
	jsr bsout
	lda #$3e
	jsr bsout
	lda #0
	sta cnt0		; init double pixel counter (to 4)
	sta cnt1		; init tile counter (to 20)
	sta cnt2		; init tile line counter (to 8)
	sta cnt3		; init line counter (to 100)
	sta byte		; init data byte
	jsr setclip	; set 4bit start address

---	lda getdata+1	; save current vector to start of clip
	pha
	lda getdata
	pha
--	ldy #0
-	lda (getdata),y	; read one line:
	pha
	lsr
	lsr
	lsr
	lsr
	tax		; get 2 pixels (1 tile)
	lda convert,x	; convert to vdc colors
	and #$f0
	sta byte
	pla
	and #15
	tax
	lda convert,x
	and #15
	ora byte
	jsr bsout
	sty ymerk
	jsr action	; activity
	ldy ymerk
	iny
	cpy #4		; one tile finished?
	bcc -

	clc		; yes, next tile
	lda getdata
	adc #32
	sta getdata
	bcc +
	inc getdata+1
+	inc cnt1		; cnt tiles to 20
	lda cnt1
	cmp #20
	bcc --

	ldy #0
	sty cnt1		; re-init cnt
	pla		; then re-get start of current line
	sta getdata
	tax
	pla
	sta getdata+1

	txa		; address next line of a tile
	clc
	adc #4
	sta getdata
	bcc +
	inc getdata+1

+	inc cnt3		; count to 100
	lda cnt3		; already 100 lines?
	cmp #100
	bcs ++		; yes, image finished

	inc cnt2		; already 8 lines (of a tile)?
	lda cnt2
	cmp #8
	bcc ---		; yes, address next row

	sty cnt2		; .y=0, re-init cnt
+ 	lda getdata	; one row finished
	clc
	adc #$e0		; add 640 for next row
	sta getdata
	lda getdata+1
	adc #4
	sta getdata+1
	bne ---		; and turn over

++	sec
	rts		; finished

; ---------------------------------------- Compute Start address of Clip

setclip	lda #>sy_4bit	; 4Bit starting from $4000
	sta getdata+1
	ldy #<sy_4bit
	sty getdata
	rts

; ----------------------------------------- 
; ----------------------------------------- Disk Access Routines
; ----------------------------------------- 

pw	!pet "w,p,"
sigtx	!pet "cdv."	; Signatur ".vdc"
sigtxs	!scr "cdv."
drinit	!pet "i0"
wflen	!by 0

; ----------------------------------------- Filehandling

wopen	jsr inull		; Initialize
	bne err8
	ldy wflen		; ",p,w" anhängen
	ldx #3
wo1	lda pw,x
	sta ls_nambuf,y
	iny
	dex
	bpl wo1
	sty wflen
	lda #12		; OPEN 12,drive,12,"name,p,w"
	tay
	ldx ls_drive
	jsr filpar
	lda wflen
	ldx #<ls_nambuf
	ldy #>ls_nambuf
	jsr filnam
	jsr copen
	jmp err9
;
inull	ldx #<drinit	; Initialize Drive
	ldy #>drinit
	lda #2
	jsr gd_sendcom

err9	jsr gd_xmess
	lda ls_err2	; liefert Fehlernummer der Floppy
	and #15		; und zwar als Bytewert (wenn <>0, dann Fehler)
err8 	sec
	rts

; ----------------------------------------- 
; ----------------------------------------- Activity Handler
; ----------------------------------------- 

messout	ldx #<message	; Textausgabe
	ldy #>message
	jmp gd_xtxout2

tcopy	ldy #0		; Informationstextauswahl (hinter Label "txt"), Offset auf Text in .x
tc0 	lda txt,x
	beq clrmess
	sta message,y
	inx
	iny
	bne tc0

clrmess	ldx #25		; Puffer für Balken löschen
	lda #32
cl0	sta mess,x
	dex
	bpl cl0
	ldy #0		; Balkenlänge 0
	ldx #7		; Dicke am Ende 0
	sty offy
	stx offx
	rts

action 	dec adcnt		; Activity, aktiviert sich nur bei 0 (Zähler abgelaufen)
	bne ld4
	lda cntwert	; dann: Reload des Zählers
	sta adcnt
	ldy offy		; Offset auf Balkenende
	cpy clrmess+1	; Ende der Ausgabezeile erreicht?
	bne act0
	jsr clrmess	; ja, re-Init des Status-Bereichs
act0	ldx offx		; offx: Index auf aktuelles Zeichen für Dicke des Balkenendstücks
	lda filltab,x
	sta mess,y
	jsr messout	; ganzen Balken ausgeben
	dec offx		; Endstück nächstes Mal dicker
	bpl ld4		; bis Endstück gefüllt
	inc offy		; dann den Balken selbst verlängern
	lda #7		; nächstes Endstück wieder dünn
	sta offx
ld4 	rts

filltab	!by 160,93,103,127,126,124,105,109	; Zeichen der Endstücke des Balkens (von hinten nach vorne)
cntwert	!by 40		; 40*8*25=8000: gauge bar

txt	!scr " VDC  ",0	; der Text mit Offset 0

message	!fill 6,32	; 6 Zeichen für Informationstext (Anzahl kann geändert werden, dann "mess" und CLRMESS anpassen)
mess	!fill 26,32	; 26 Zeichen für Fortschrittsbalken, Länge von message und mess zusammen immer 32!
	!by 0		; hier Wert=26 (bei CLRMESS Wert minus 1)!

; ----------------------------------------- 
; ----------------------------------------- Image Information Handler
; ----------------------------------------- 

getname	ldx #0		; aktuellen Filenamen sichern
si0	lda ls_lastname,x
	beq si1
	sta nbuf,x
	inx
	cpx #16
	bcc si0
si1	rts

setname	lda #0		; Namen in Image am Ende in Info eintragen
	ldx #<ls_picname
	ldy #>ls_picname
si3	stx sc_texttab
	sty sc_texttab+1
	tax
	ldy #0
si4	lda nbuf,x
	beq si5
	sta (sc_texttab),y
	inx
	iny
	bne si4
si5	rts
;
nbuf	!fill 16,32	; Namenspuffer
	!by 0

; ----------------------------------------- 
; ----------------------------------------- Namen verlängern
; ----------------------------------------- 

addsig	pha		; Länge merken
	tay
	dey
	ldx #0
ag4	lda ls_nambuf,y	; endet auf ".vdc"?
	cmp sigtx,x
	bne ag2		; nein
	dey
	inx
	cpx #4
	bcc ag4
	pla		; ja, fertig
	rts

ag2	pla
	tay		; Name länger als 12 Zeichen?
	cpy #13
	bcs ag0		; ja, behandeln

ag5	ldx #3		; nein, ".vdc" anhängen
ag1	lda sigtx,x
ag3	sta ls_nambuf,y
	lda sigtxs,x	; auch für Image Information
	sta ls_lastname,y
	iny
	dex
	bpl ag1
	sty wflen		; neue Länge merken, fertig
	sty ls_flen
	rts

ag0	dey		; auf 12 verkürzen
	cpy #12
	bne ag0
	beq ag5		; unbed. Sprung

; ----------------------------------------- 
; ----------------------------------------- Data
; ----------------------------------------- 

convert	!by $00,$22,$cc,$11,$88,$aa,$dd,$11
	!by $33,$99,$44,$ee,$77,$dd,$55,$ff

	; godot colors to vdc colors (ora and mgr missing in c128 palette!)

modend 	!eof
