
	!src "godotlib.lib"	; Label-Library einbinden
	*= $c000		; generelle Startadresse für alle Module
	!ct pet		; Texte werden in PETSCII assembliert

; ----------------------------------------- 
;
; svr.Basic8
;  Saver für C128 Basic8-Bilder
;
;  1.00, 27.04.19, first release
;  1.01, 02.05.19, bugfix: compress algorithm now works
;                  added: auto prefix ("brus.")
;                  added: options requester
;
; ----------------------------------------- 


; ----------------------------------------- Equates

	dst		= $30
	dst0		= $32
	cpres		= $34	; file compressed? (if 1)
	cflag		= $35	; running compression? (if $80)
	dbl		= $36	; double height? (0: off, $ff: on)
	vertcnt		= $37
	byte		= $38
	bitcnt		= $39	; double width? (1: off, 2: on)
	bcnt1		= $3a
	src		= $3b
	hold		= $3d
	src0		= $3e
	adcnt		= $40
	lcnt8		= $41
	lcnt		= $42
	cnt		= $43
	cnteq		= $44
	ocnt		= $45
	xmrk		= $46
	current		= $48
	yndex		= $49

	offx		= $b2
	offy		= $b3

	shift		= $028d
	oszi3		= $d40e
	wave		= $d412
	filter		= $d418
	rausch		= $d41b

	buf		= $cd00
	cbuf		= buf+80
	destbuf		= $ca00

; ----------------------------------------- Header

header	jmp start
	!by $40
	!by 0
	!by 1
	!wo modend
	!wo 0
	!pet "Basic8 images   "
	!pet "1.01"
	!pet "02.05.19"
	!pet "A.Dettke        "

; ----------------------------------------- Main

start	ldx gr_nr		; Input?
	dex 
	bne saver

	jmp initinp	; ja

; ----------------------------------------- Basic8mono

saver	lda gd_modswitch	; Modulmanagement
	pha 

	lda ls_flen	; Keine Datei ausgewählt?
	beq st1		; ja, fertig

	sta wflen		; Namenslänge merken
	lda #1		; Activity beginnen
	sta adcnt

	ldx #<b8lst	; Requester
	ldy #>b8lst
	jsr gd_screen
	jsr gd_eloop	; warten auf Klicks

st1	pla 
	sta gd_modswitch

	lda shift		; Shift (-Lock) gedrückt?
	and #1
	bne evleave

	ldy #16		; nein, Balancing-Tabelle initialisieren
	sty gr_ctr
	sty gr_brt
lll	dey 
	tya 
	sta gr_btab,y
	bne lll

; ----------------------------------------- Event: Beenden

evleave	lda #0
	sta wflen
	sec 		; fertig
	rts 

; ----------------------------------------- Event: Save Image

evsaveb8	lda wflen
	beq +

	jsr addprefix	; Prefix "brus." zufügen
	jsr gd_sproff	; Mauszeiger aus

	jsr wopen		; Datei öffnen
	bne st2		; Fehlschlag?

	jsr getname	; nein, Image Info vorbereiten
	ldx #12
	jsr ckout
	jsr write		; Datei speichern

st2	jsr clrch		; Datei schließen
	lda #12
	jsr close
	jsr err9		; Fehler?
	bne +
	jsr setname	; nein, Image Info eintragen

+	jmp gd_spron	; Mauszeiger an

; ----------------------------------------- 
; ----------------------------------------- Input-Routinen
 
	!src "input.inc"

; ----------------------------------------- 
; ----------------------------------------- 


; ----------------------------------------- Disk Access

pw	!pet "w,p,"
drinit	!pet "i0"
wflen	!by 0

wopen	jsr inull
	bne err8
	ldy wflen
	ldx #3
wo1	lda pw,x
	sta ls_nambuf,y
	iny 
	dex 
	bpl wo1
	sty wflen
	lda #12
	tay 
	ldx ls_drive
	jsr filpar
	lda wflen
	ldx #<ls_nambuf
	ldy #>ls_nambuf
	jsr filnam
	jsr copen
	jmp err9

; ----------------------------------------- 

inull	ldx #<drinit
	ldy #>drinit
	lda #2
	jsr gd_sendcom

err9	jsr gd_xmess
	lda ls_err2
	and #15
err8	sec 
	rts 

; ----------------------------------------- Messages

messout	ldx #<message
	ldy #>message
	jmp gd_xtxout2

tcopy	ldy #0
tc0	lda txt,x
	beq clrmess
	sta message,y
	inx 
	iny 
	bne tc0

action	dec adcnt
	bne ld4
	lda cntwert
	sta adcnt
	ldy offy
	cpy #23
	bne act0
	jsr clrmess
act0	ldx offx
	lda filltab,x
	sta mess,y
	jsr messout
	dec offx
	bpl ld4
	inc offy
	lda #7
	sta offx
ld4	rts 

clrmess	ldx #23
	lda #32
cl0	sta mess,x
	dex 
	bpl cl0
	ldy #0
	ldx #7
	sty offy
	stx offx
	rts 

filltab	!by 160,93,103,127,126,124,105,109

cntwert	!by 1

txt	!scr " Basic8 @"

message	!fill 8,32
mess	!fill 24,32
	!by 0

; ----------------------------------------- Image Information

getname	ldx #0
si0	lda ls_lastname,x
	beq si1
	sta nbuf,x
	inx 
	cpx #16
	bcc si0
si1	rts 

setname	lda #0		; Namen in Image Info eintragen
	ldx #<ls_picname
	ldy #>ls_picname
si3	stx sc_texttab
	sty sc_texttab+1
	tax
	ldy #0
si4	lda nbuf,x
	beq si5
	sta (sc_texttab),y
	inx
	iny
	bne si4
si5	rts

nbuf	!fill 16,32
	!by 0

; ----------------------------------------- Write Image

write	jsr gd_clrms	; Message ausgeben
	ldx #0
	jsr tcopy

	jsr wrheader	; Basic8-Header
	lda cmpr		; file compressed?
	beq +
	lda #$80		; yes, tag it
+	sta cpres
	ldx dither	; Dithering berücksichtigen
	lda dlo,x
	sta dmode
	lda dhi,x
	sta dmode+1
	lda #$80
	sta filter
	sta oszi3
	sta oszi3+1
	lda #0
	sta wave
	lda #$81
	sta wave
	jsr basic8	; Bild abspeichern
;	jsr wrcolors	; Farben anhängen (folgt noch)
	sec 
	rts 

; ----------------------------------------- Bild rendern

basic8	lda #<sy_4bit
	ldx #>sy_4bit
	sta src0
	sta src
	stx src0+1
	stx src+1
	lda #0		; steuert ysize
	sta dbl
	sta vertcnt

	lda #25
	sta lcnt8
lnloop8	lda #0
	sta lcnt

lnloop	jsr action
ads0	ldx #0

zloop	lda #0
	sta yndex
	lda xzoom		; 1 bei 320, 2 zählt 640 (eine Rasterlinie)
	sta bcnt1

byloop	lda xmask		; zählt vier Byte (8 Pixel)
	sta bitcnt
	lda #0
	sta byte

btloop	ldy yndex
	lda (src),y	; linkes Pixel
	pha 
	lsr 
	lsr 
	lsr 
	lsr 
	tay 
	lda gr_btab,y	; Balancing berücksichtigen
	jsr makebyte
	ldy xzoom
-	lsr bitcnt
	dey
	bne -
	pla 
	and #$0f		; rechtes Pixel
	tay 
	lda gr_btab,y	; Balancing berücksichtigen
	jsr makebyte
	inc yndex		; nächstes Byte (von 4)
s3	ldy xzoom
-	lsr bitcnt
	dey
	bne -
	bcc btloop

	sta buf,x		; Ergebnis puffern (8 Pixel)
	inx 
	dec bcnt1		; zweimal das Ganze (bei 640)
	bne byloop

	lda src		; nächste Kachel ansteuern
	clc 
	adc #32
	sta src
	bcc s4
	inc src+1
s4	cpx xtiles
	bne zloop

	jsr moveline	; Rasterzeile wegschreiben bis Blockzeile voll

	ldx vertcnt	; Zeile verdoppeln
	inx 
	cpx #8
	bne s41
	ldx #0
s41	stx vertcnt
	lda dbl
	eor yzoom
	sta dbl
	beq newline

	lda src0		; ja, Zeiger zurücksetzen
	sta src
	lda src0+1
	sta src+1
	bne ads0		; noch einmal

newline	lda src0		; nächste Rasterzeile
	clc 
	adc #4
	sta src0
	sta src
	bcc s5
	inc src0+1
s5	lda src0+1
	sta src+1
	inc lcnt
	lda #8
	cmp lcnt
	beq s51
	jmp lnloop	; Sprung, wenn Kachel noch nicht durch

s51	lda src0		; sonst: nächste Kachelzeile
	clc 
	adc #<1248
	sta src0
	sta src
	lda src0+1
	adc #>1248
	sta src0+1
	sta src+1
	dec lcnt8		; zählen (bis 25)
	beq done
	jmp lnloop8	; von vorn
done	rts 		; bzw. fertig

; ----------------------------------------- Verteiler für Dither

makebyte	jmp (dmode)

; ----------------------------------------- Dithering

dithoff	cmp #8
	bpl do0
	lda #0
	!by $2c
do0	lda bitcnt
	ora byte
	sta byte
	rts 

dithrst	ldy vertcnt
	ora offs,y
	tay 
	lda gr_orderedpat,y
	and bitcnt
	ora byte
	sta byte
	rts 

dithpat	asl 
	asl 
	asl 
	ora vertcnt
	tay 
	lda gr_pattern,y
	and bitcnt
	ora byte
	sta byte
	rts 

dithnoi	beq dn0
	cmp #15
	beq dn1
	ldy #0
	sta hold
	lda rausch
	and #$0f
	cmp hold
	bcs dn3
	ldy #$aa
dn3	lda rausch
	and #$0f
	cmp hold
	tya 
	bcs dn2
	ora #$55
dn2	!by $2c
dn1	lda #$ff
	and bitcnt
dn0	ora byte
	sta byte
	rts 

dithrnd	cmp #8
	beq dr0
	bcs dr1
	bcc dr2
dr0	lda rausch
	!by $2c
dr1	lda bitcnt
	and bitcnt
	!by $2c
dr2	lda #0
	ora byte
	sta byte
ml4	rts 

; ----------------------------------------- 

moveline	lda vertcnt
	bne ml0
	lda #<destbuf
	ldy #>destbuf
	sta dst
	sty dst+1
ml0	ldy #0
	ldx #0
mloop	lda buf,x
	sta (dst),y
	inc dst
	bne ml3
	inc dst+1
ml3	inx 
	cpx xtiles
	bne mloop
	ldy vertcnt
	cpy #7		; nach 8 Rasterzeilen speichern
	bne ml4

writeloop	ldx #8		; 8*80 =640 Bytes (1 Blockzeile)
	lda #<destbuf
	ldy #>destbuf
	sta dst0
	sty dst0+1
	ldy #0		; Wiederholungszähler auf Null
	sty cnt
	sty cnteq
	sty cflag
	sty byte		; reset lastbyte

wloop	lda (dst0),y	; Speichern: Byte holen,
	jsr pack		; packen und wegschreiben
	iny 
	cpy xtiles
	bne wloop
	clc 
	lda dst0
	adc xtiles
	sta dst0
	bcc wl5
	inc dst0+1
wl5	ldy #0
	dex 
	bne wloop

	bit cpres		; ja, File ungepackt?
	bmi +
	rts		; dann raus

+	lda cnt		; sonst: flush buffer?
	tax
	ora cnteq
	beq ++		; nicht erforderlich
	txa		; doch: welchen?
	beq +

	sta ocnt		; flush uncompacted buffer
	jsr straight
	beq ++

+	jsr compact	; flush compacted buffer
++	stx cnteq
	rts		; jetzt: 640 Bytes fertig
	

; ----------------------------------------- RLE-Komprimierung

pack	bit cpres		; Komprimierung aktiviert?
	bmi +
	jmp bsout		; nein, unkomprimiert speichern

+	sta current
	stx xmrk		; sonst: .x retten
-	ldx cnt		; Zähler holen, neues Byte?
	beq wl1		; ja, merken
	cpx #127		; höchsten Zählerstand erreicht?
	bcc +

	jsr process	; ja, max buffer bearbeiten
	stx cnteq
	beq -		; dann normal fortsetzen

+	lda current
	cmp byte		; aktuelles Byte gleich letztem Byte?
	bne wl1		; nein, speichern

	inc cnteq		; ja, zählen
	lda cnteq
	cmp #3		; 3 erreicht?
	bcc ++
	lda #$80		; dann Komprimierungsflag setzen
	sta cflag
	bmi ++

wl1	lda cnteq		; aktives Packen?
	beq ++
	cmp #3
	bcc +
	jsr process	; ja, ausführen
+	lda #0
	sta cnteq

++	lda current	; sonst: 
	sta byte
incr	sta cbuf,x	; Byte puffern
	inc cnt		; und zählen
	ldx xmrk		; .x rekonstruieren
	rts 

; ----------------------------------------- Komprimierung durchführen

process	txa
	clc
	sbc cnteq
	sta ocnt
	beq compact
	jsr straight

compact	ldx cnteq		; sonst compress:
	inx
-	txa
	ora #$80		; Zähler ausgeben
	jsr bsout
	lda byte		; last Byte ausgeben
	jsr bsout

wl3	ldx #0		; dann Zähler zurücksetzen
	stx cnt
	stx cflag
	stx ocnt
	rts

wl2	sta cbuf,x	; Wert 127 puffern
	bit cflag		; aktive Komprimierung?
	bmi -
	stx ocnt
	txa

straight	jsr bsout		; Zähler ausgeben
	ldx #0
-	lda cbuf,x	; Puffer ausgeben
	jsr bsout
	inx
	cpx ocnt
	bne -
	beq wl3		; Werte zurücksetzen (unbed. Sprung)

; ----------------------------------------- Basic8-Header schreiben

wrheader	ldx #0
wrh0	lda b8header,x
	jsr bsout
	inx 
	cpx #18
	bne wrh0
	rts 

; ----------------------------------------- Namen verlängern

addprefix	pha		; Länge merken
	ldy #0
ag4	lda ls_nambuf,y	; beginnt mit "brus."?
	cmp prefix,y
	bne ag2		; nein
	iny
	cpy #5
	bcc ag4
	pla		; ja, fertig
	rts
	
ag2	pla		; verlängern um 5 Zeichen
	clc
	adc #5
	tay		; Name nun länger als 16 Zeichen?
	cpy #16
	bcs ag0		; ja, behandeln

ag5	ldx #10		; nein, "brus." vor den Namen
ag1	lda ls_nambuf,x
	sta ls_nambuf+5,x
	lda ls_lastname,x
	sta ls_lastname+5,x
	dex
	bpl ag1
	ldx #4		; Länge
ag3	lda prefix,x
	sta ls_nambuf,x
	lda prefixs,x
	sta ls_lastname,x
	dex
	bpl ag3
	sty wflen		; neue Länge merken, fertig
	sty ls_flen
	rts

ag0	dey		; auf 16 verkürzen
	cpy #16
	bne ag0
	beq ag5		; unbed. Sprung

; ----------------------------------------- Event: XSize

evxsize	ldx xsize		; 0: off, 1: on
	beq +
	ldx #$ff
+	lda #40
	inx
	beq +
	asl
+	sta xtiles
	sta wid
	stx xsize
	lda #$80
	cpx #0
	beq +
	ora #$40
+	sta xmask
	lda #<xsizetx
	sta sc_texttab
	lda #>xsizetx
	sta sc_texttab+1
	txa
	inx
	stx xzoom
	asl
	tay
	lda xaddrs,y
	tax
	lda xaddrs+1,y
	tay
	jmp gd_xtxtggl

; ----------------------------------------- Event: YSize

evysize	ldx ysize		; 0: off, 1: on
	beq +
	ldx #$ff
+	lda #200
	inx
	stx hgt+1
	bne +
	sta hgt
	beq ++
+	lda #$90
	sta hgt

++	stx ysize
	beq +
	lda #$ff
	!by $2c
+	lda #0
	sta yzoom
	lda #<ysizetx
	sta sc_texttab
	lda #>ysizetx
	sta sc_texttab+1
	txa
	asl
	tay
	lda yaddrs,y
	tax
	lda yaddrs+1,y
	tay
	jmp gd_xtxtggl

; -------------------------------------- Event: Set Compress Mode

evsetcmpr	ldx cmpr		; 0: off, 1: on
	beq +
	ldx #$ff
+	inx
	stx cmpr
	lda #<cmprstx
	sta sc_texttab
	lda #>cmprstx
	sta sc_texttab+1
	txa
	asl
	tay
	lda caddrs,y
	tax
	lda caddrs+1,y
	tay
	jmp gd_xtxtggl

; ----------------------------------------- Event: Set Color Mode

evsetmode	lda modes
	cmp #4
	bne +
	lda #$ff
	sta modes
+	inc modes
	ldx modes
	stx mode
	lda modeoffs,x
	tax
	ldy #3
-	lda modetxts,x
	sta modetx,y
	dex
	dey
	bpl -
	ldy #0
	jsr settext
	ldy #6
	jmp gd_xtxout1

; ----------------------------------------- Event: Set Dither Mode

evsetdith	lda dither
	cmp #4
	bne +
	lda #$ff
	sta dither
+	inc dither
	ldx dither
	lda dithoffs,x
	tax
	ldy #6
-	lda dithtxts,x
	sta dithtx,y
	dex
	dey
	bpl -
	ldy #2
	jsr settext
	ldy #6
	jmp gd_xtxout1

; ------------------------------------ Output gadget text routines

tabigad	!wo modegad	; 0
	!wo dithgad	; 2

settext	lda #<tabigad
	sta ls_vekta8
	lda #>tabigad
	sta ls_vekta8+1
; ---	rts

gettext	lda (ls_vekta8),y
	sta sc_screentab
	iny
	lda (ls_vekta8),y
	sta sc_screentab+1
	lda #0
	tax
	tay
gt0	jsr gd_setpos
	cpx #3
	bne gt0
	stx sc_ho
	jsr gd_trim
	jmp gd_initmove

; ----------------------------------------- Screenlist

b8lst	!by 0
	!by 5,12,15,15,$81
	!wo 0
	!scr "Save Basic8",0
	!by 7,22,5,3,$cd
	!wo evxsize
xsizetx	!scr "320",0
	!by 9,22,5,3,$ce
	!wo evysize
ysizetx	!scr "200",0
	!by 11,22,5,3,$ce
	!wo evsetcmpr
cmprstx	!scr "yes",0
modegad	!by 13,21,6,3,$ce
	!wo evsetmode
modetx	!scr "mono",0
dithgad	!by 15,18,9,3,$ce
	!wo evsetdith
dithtx	!scr "Ordered",0
	!by 17,13,6,3,$cc
	!wo evsaveb8
	!scr "Save",0
	!by 17,19,8,3,$ce
	!wo evleave
	!scr "Cancel",0
	!by $c0,7,12,6
	!scr "XSize:",0
	!by $c0,9,12,6
	!scr "YSize:",0
	!by $c0,11,12,9
	!scr "Compress:",0
	!by $c0,13,12,7
	!scr "Colors:",0
	!by $c0,15,12,5
	!scr "Dith:",0
	!by $80
	
; ----------------------------------------- Data

prefix	!pet "brus."	; Länge: plus 5, max 11
prefixs	!scr "brus."

xsizet1	!scr "320@"
xsizet2	!scr "640@"
xsize	!by 0
xzoom	!by 1		; 1: off, 2 : on
xtiles	!by 40		; zoom off: 40, on: 80
xmask	!by $80		; zoom off: $80, on: $c0
xaddrs	!wo xsizet1,xsizet2

ysizet1	!scr "200@"
ysizet2	!scr "400@"
ysize	!by 0		; 0: off (200), 1: on (400)
yzoom	!by 0		; 0: 200, $ff: 400
yaddrs	!wo ysizet1,ysizet2

cmprst1	!scr " no@"
cmprst2	!scr "yes@"
caddrs	!wo cmprst1,cmprst2

modetxts	!scr "mono8x2 8x4 8x8 8x16"
modeoffs	!by 3,7,11,15,19
modes	!by 0

dithtxts	!scr "  Off  OrderedPattern Noise Random "
dithoffs	!by 6,13,20,27,34
dither	!by 1

offs	!by $00,$10,$20,$30
	!by $00,$10,$20,$30

dlo	!by <dithoff
	!by <dithrst
	!by <dithpat
	!by <dithnoi
	!by <dithrnd

dhi	!by >dithoff
	!by >dithrst
	!by >dithpat
	!by >dithnoi
	!by >dithrnd

dmode	!by 0,0

; ----------------------------------------- Basic8 Header

b8header	!wo 0		; Startadresse (im VDC)
	!tx "brus"	; Kennung
	!by 4		; Typ: Grafik
	!by 0		; Startspalte
	!wo 0		; Startlinie
cmpr	!by 1		; Packflag (1=ja)
mode	!by 0		; Anzahl Farben (0=mono)
wid	!by 40		; Breite in Kacheln (80=640 Pixel)
hgt	!wo 200		; Höhe in Linien
	!by 1		; BGR (dark grey)
	!by 14		; FGR (light grey)
	!by 0		; Border (black)

; ----------------------------------------- 

modend	!eof 
