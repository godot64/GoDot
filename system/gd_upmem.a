
	!src "godotlib.lib"
	*= $c000

;    ---------------------------------------------------
; ***                                                   ***
; ***  GoDot UpMem                                      ***
; ***                                                   ***
; ***                                                   ***
; ***                                                   ***
; ***  1.08, 22.08.92,                                  ***
; ***                                                   ***
; ***  1.10, 14.11.92                                   ***
; ***  1.11, 22.11.92                                   ***
; ***  1.12, 03.02.93                                   ***
; ***  1.13, 02.04.93                                   ***
; ***  1.14, 16.08.93,                                  ***
; ***        01.11.00, complete comment revision        ***
; ***  1.15, 04.12.17, optimized code to gain space,    ***
; ***                  added: set amnt of colors in pal ***
; ***  1.16, 14.07.21, added: automatic default pals    ***
; ***  1.17, 01.03.24, added: automatic Ultimate turbo  ***
; ***  1.18, 02.12.24, adapted to SuperCPU              ***
; ***                                                   ***
;    ---------------------------------------------------
;

; -------------------------------------------------- Declarations

	pport		= $01		; usually $36

	src		= $39
	col00		= $3b
	nr0		= $40
	max		= $44
	rstart		= max
	rend		= max+1
	cols		= $46
	zp1		= $47
	xbuf		= $48
	rstep		= xbuf
	hmzp		= $49
	cmzp		= $4a
	pbuf		= $4b

	source		= $a6
	dest		= $a8
	lflag		= $a8
	brttmp		= $a9
	crttmp		= $aa
	vblock		= $aa
	bitcnt		= $ac
	source1		= $ae
	dest1		= $b2
	hold		= $b4
	vblock1		= $b5

	irq		= $0314
	defphi		= $03ce
	scr1		= $0432
	scr2		= $0452

	sprptr		= $07fa

	fi2		= $1121
	gbox		= $1153
	patch1		= $116c
	makeline		= $11ae
	chgcols		= $17e0
	patch2		= $1814

	dithtype		= $1e36
	areatype		= $1efb

	spr2		= $3e80
	spr5		= $3f40
	bttab		= $3f40
	hist1		= $3f40
	hist		= $3f50
	btabold		= $3f50
	etab		= $3f70
	htab		= $3f80
	htab0		= $3f90
	rtab		= $3fb0


	palundo		= $be00
	palcanc		= $be10
	paldflt		= $be20

	grafreg		= $d011
	multreg		= $d016
	charreg		= $d018
	border		= $d020
	backgr		= $d021
	turbo		= $d030

	oszi3		= $d40e
	wave		= $d412
	filter		= $d418
	rausch		= $d41b

	dbuf		= $bf00
	oldirq		= $be00

	sprxy		= $d004
	xmsb		= $d010
	raster		= $d012
	sprreg		= $d015
	yexp		= $d017
	reqirq		= $d019
	rirqen		= $d01a
	sprpri		= $d01b
	sprmulti		= $d01c
	xexp		= $d01d
	sprcol2		= $d025
	sprcol3		= $d026
	sprcol1		= $d029

	cram		= $d800

	jf2		= $dc00
	ciairq		= $dc0d
	ciactrla		= $dc0e

	home		= $e566
	scroll		= $e968

	cstart		= $fe0b
	vram1		= $de0b
	vram2		= $ee0b

; -------------------------------------------------- Header

	jmp start
	!by $20
list	!wo 0
	!wo modend
breit1	!by $12
breit2	!by $24
	!pet "GoDot f000 slot4"
created	!pet "1.18"
	!pet "02.12.24"
	!pet "A.Dettke/W.Kling"
;
; -------------------------------------------------- Module Management

start	stx pdis		; .x=0; clear flag (request from palette requester)
	ldx sc_screenvek	; save vector to main screen screenlist
	stx list
	ldx sc_screenvek+1
	stx list+1

	ldx gr_nr		; get function number
	beq jevbal	; 0: Balancing
	dex
	beq jevpal	; 1: Palette
	dex
	beq jevdispl	; 2: Display
	dex
	beq jevdith	; 3: Dithermode
	dex
	beq jevarea	; 4: Toggle Clip/Full
	dex
	beq jevinfo	; 5: GoDot Guru
	dex
	beq jevprviu	; 6: Switch Preview on
	dex
	beq jevdisp2	; 7: Redisplay

	clc
	rts

jevdispl    jmp evdisplay	; 2
jevpal      jmp evpal	; 1
jevbal      jmp evbal	; 0
jevdith     jmp evdith	; 3
jevarea     jmp evarea	; 4
jevprviu    jmp evprviu	; 6
jevdisp2    jmp evdisp2	; 7
jevinfo     jmp evinfo	; 5

; --------------------------------------------------
; -------------------------------------------------- Show graphics
; --------------------------------------------------

redisplay	ldx gr_palette	; bordercolor is palette entry 0
	stx border
	jsr setcolors	; reget colors
	lda gr_cmode	; which graphics mode?
	beq dp4
	lda #$18		; multi when 2
	sta multreg
dp4	lda #$1b		; hires when 0
	sta charreg
	lda #$3b
	sta grafreg
	lda gr_redisp	; image already rendered?
	bne dp3
	sta sc_keyprs	; yes, clear keypressed
	pla		; clear stack
	pla
dp1	lda sc_keyprs	; wait for key or STOP
	ora sc_stop
	beq dp1
	jsr getcolors	; save colors
	jsr tmode		; switch textmode on
	lda sc_screenvek	; save vector to current screenlist
	pha
	lda sc_screenvek+1
	pha
	lda pdis		; is palette requester working?
	beq dp5
	ldx list		; yes, rebuild main screen
	ldy list+1
	jsr gd_screen
dp5	pla		; rebuild palette requester
	tay
	pla
	tax
	jsr gd_screen
dp3	lda #0		; deactivate turbo on Ultimate64
	sta turbo
	clc		; finished (stay in list)
	rts

; -------------------------------------------------- Switch Textmode on

tmode	ldx #$13
	lda #$1b
	stx charreg
	sta grafreg
	lda #$08
	sta multreg
	lda sc_maincolor
	sta border
	sta backgr
	rts

; -------------------------------------------------- Graphics Colors Management

setcveks	sei		; called from GETCOLORS
	lda #$35		; set C64 to IO off
	sta pport
	lda #>(cstart)	; first: save 1000 color RAM nibbles to loader area
	ldx #$d8		; from $d800
	bne scv0
setbveks	lda #>(vram1)	; second: save upper 500 video RAM bytes to saver area
	ldx #$04		; from $0400
	dec pport		; set C64 completely to RAM
scv0	stx dest1+1
	ldy #$00
	sty sc_merk
	sty dest1
	dey
setlast	sty gr_bkcol	; third: save lower 500 video RAM bytes to module area
	ldy #<(cstart)
	sty sc_vekt20	; vector to data
	sta sc_vekt20+1
	lda #<(500)	; counter
	sta ls_vekta8
	lda #>(500)
	sta ls_vekta8+1
	ldy #$00
	rts

; -------------------------------------------------- Counters

count	inc sc_vekt20	; increment source data vector
	bne cou5
	inc sc_vekt20+1
cou5	inc dest1		; increment destination data vector
	bne cou6
	inc dest1+1
cou6	lda ls_vekta8	; decrement counter
	bne cou7
	dec ls_vekta8+1
cou7	dec ls_vekta8
	lda ls_vekta8	; until zero
	ora ls_vekta8+1
	rts

; -------------------------------------------------- Save Graphics Colors

getcolors	jsr setcveks	; set vectors accordingly
stco	lda (dest1),y	; compress $d800-nibbles
	sta sc_merk
	inc dest1
	bne stc0
	inc dest1+1
stc0	lda (dest1),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lda sc_merk
	sta (sc_vekt20),y	; and buffer them
	jsr count
	bne stco

	jsr setbveks	; buffer video RAM, part 1
stc1	lda (dest1),y
	sta (sc_vekt20),y
	jsr count
	bne stc1
	ldy gr_bkcol	; flag: last time?
	bpl scv1		; yes, finished

	ldy #$00		; buffer video RAM, part 2
	lda #>(vram2)
	jsr setlast
	beq stc1		; unconditional branch

scv1	lda #$36		; set C64 to BASIC off
	sta pport
	cli
	lda backgr	; set graphics background color value
	and #$0f
	sta gr_bkcol
	rts

; -------------------------------------------------- Restore Graphics Colors

setcolors	lda gr_bkcol	; restore background color
	sta backgr
	pha		; save for last time

	jsr setcveks	; set vectors accordingly
stc2	sty sc_merk	; decompress color RAM nibbles
	lda (sc_vekt20),y
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	lsr
	rol sc_merk
	sta (dest1),y	; and store them
	inc dest1
	bne stc3
	inc dest1+1
stc3	lda sc_merk
	sta (dest1),y
	jsr count
	bne stc2

	jsr setbveks	; restore video RAM, part 1
stc4	lda (sc_vekt20),y
	sta (dest1),y
	jsr count
	bne stc4

	ldy gr_bkcol	; flag: last time?
	bpl scv1		; yes, finished

	pla		; restore video RAM, part 2
	tay
	lda #>(vram2)
	jsr setlast
	beq stc4

; --------------------------------------------------
; -------------------------------------------------- Palette Management
; --------------------------------------------------

tabigad	!wo pickbox	; text output routines
	!wo palbox
	!wo pick
;
settab	lda #<(tabigad)
	sta sc_texttab
	lda #>(tabigad)
	sta sc_texttab+1
	rts
;
gettab	lda (sc_texttab),y
	sta sc_screentab
	iny
	lda (sc_texttab),y
	sta sc_screentab+1
	iny
	sty sc_merk
	stx sc_merk+1
	jmp bgt1

; -------------------------------------------------- Subevent: Display from Palette Requester

se_paldis	jsr evdisplay	; switch graphics mode on

; --------------------------------------------------

palcols	inx		; .x was 0; set index to Normal Text color
	inx
	jsr gd_fcol	; colorize "Pick Color." message

	ldy #$00		; care for textmode
	sty sc_loop
	jsr settab	; set output vector

	ldx #$02		; prepare palette gadgets
ep0	jsr gettab
	jsr gd_invert	; invert them (to show colors later)
	ldy sc_merk
	ldx sc_merk+1
	dex
	bne ep0

ppal	jsr settab	; re-set output vector
	ldy #$00		; start with upper palette gadget
	sty sc_chgcol	; and with black
	ldx #$0f		; 16 colors
	jsr gettab
	ldy #$02		; width: 2 tiles
	sty sc_br
ep1	jsr setcol
	inc sc_chgcol	; increment color (standard palette)
	dec sc_merk+1	; count colors
	bpl ep1

	jsr gettab	; now lower palette gadget (.y=0)
	ldx #2
	stx sc_br
ep2	lda gr_palette,y	; get color entry
	sta sc_chgcol
	jsr setcol
	inc sc_merk+1	; increment color index (GoDot palette)
	ldy sc_merk+1	; last valid entry?
	cpy gr_howmany
	bcc ep2		; no, loop

ep3	ldx gr_picked	; color selected?
	bmi ep44		; no, finished

	stx sc_chgcol	; yes, colorize "Picked" gadget
ep9	lda #$00		; care for textmode
	sta sc_loop
	jmp eps7		; continue there

setcol	ldx #$04		; index to color
	jsr gd_fcol	; colorize (.x=0)
	inc sc_sp		; increment tile offset
	inc sc_sp
	rts

; -------------------------------------------------- Event: Palette Requester

evpal	jsr gd_savescvek	; save vector to main screenlist
	sta pdis		; set Flag: rebuild Palette requester

	jsr buildreq
	ldx #$0f		; initialize palette buffers
ep5	lda gr_palette,x	; get 16 current palette values
	sta palundo,x	; store to undo area
	sta palcanc,x	; store to nothing changed area
	lda gr_basepal,x	; get base palette values
	sta paldflt,x	; store to default palette area
	dex
	bpl ep5
	ldx gr_howmany	; store for undo
	dex
	stx sy_soffy+1
	jmp gd_eloop	; wait for further events

; -------------------------------------------------- Subevent: More Colors

se_morec			; (different places on screen!)

; -------------------------------------------------- Subevent: Less Colors

se_lessc	lda #$4c		; JMP
	sta patch2
	jsr chgcols
	jsr shiftprs	; ### 1.16
	beq +
	jsr se_pdeft
+	lda #$20		; JSR
	sta patch2

; --------------------------------------------------

buildreq	lda gr_howmany	; compute width of GoDot palette gadget
	asl
	tax
	inx
	inx
	stx palbox+2

	ldx #<pallst	; show requester
	ldy #>pallst
	jsr gd_screen

	ror		; .a=$80
	sta gr_picked	; set Picked invalid
	jsr palcols	; show palettes

ep44	clc
	rts

; -------------------------------------------------- Subevent: Cancel Palette Requester

se_pcanc	lda sy_soffy+1	; re-set # of colors
	sta gr_howmany
	jsr chgcols	; .x=0
	stx gr_redisp	; flag: don't re-render

	ldx #$1f		; get PALCANC
ep7	ldy #$0f
ep6	lda palundo,x
	sta gr_palette,y	; and restore palette
	dex
	dey
	bpl ep6

	jsr ep3		; care for Picked gadget
ep61	lda #$80		; set Picked value to invalid
	ora gr_picked
	sta gr_picked

; -------------------------------------------------- Subevent: Accept Palette Changes

se_pacc	sec		; leave requester to main screen
	rts

; -------------------------------------------------- Subevent: Set Default Palette

se_pdeft	ldx gr_howmany	; get number of colors to be rendered
	cpx #$10		; is 16?
	bne dpl1
	lda #$ff		; yes, set flagword to $ffff
	sta sc_merk+1
	bne dpl2
dpl1	dex		; no, index minus 2
	dex
	lda defphi,x	; get flagword for this particular palette
	sta sc_merk+1
	lda gr_defpals,x
dpl2	sta sc_merk

	ldy #$00		; palettes are coded bitwise
	ldx #$00		; index into base palette
dpl	asl sc_merk+1	; shift flags left
	rol sc_merk
	bcc dps
	lda gr_basepal,x	; bit set: get associated color
	sta paldflt,y	; enlist in current palette
	iny
	cpy gr_howmany	; until all colors
	beq dpok

dps	inx		; increment index
	cpx #$10		; until 16
	bne dpl

dpok	ldx #$2f		; move palettes
ep8	jsr ep7
	jmp eps8		; show new (default) palette

; -------------------------------------------------- Subevent: Undo Change to Palette

se_pundo	ldx #$0f		; restore current palette
	bne ep8		; and display

; -------------------------------------------------- Subevent: Pick a Color

se_ppick	ldx gr_picked	; first get current picked color
	lda sc_merk	; get screen position: row
	sta sc_zl
	lda sc_merk+1	; and column
	sta sc_sp
	inc sc_loop	; care for colormode
	jsr gd_initmove	; compute address of this position in color RAM
	lda (sc_vekt20),y	; .y=0; retrieve picked color
	and #$0f
	sta gr_picked	; store value
	sta sc_chgcol
	sta sc_merk+1
	jsr settab	; get vector address

	txa		; get current picked color
	bpl ep91		; repeatedly picked a color?

	dec sc_loop	; no, care for textmode
eps7	ldy #$04		; index to gadget descriptor address
	jsr gettab	; compute destination
	jsr gd_invert	; invert gadget
	ldx #$04		; index to new color (points to sc_chgcol)
	jsr gd_fcol	; and colorize it
	beq ep4		; unconditional branch, finished

ep91	ldx sc_merk+1	; yes, get picked color
	ldy #$04		; compute destination
	jsr gettab
	lda sc_merk+1	; get color
	jsr gd_fi0	; show color
ep4	clc		; finished
	rts

; -------------------------------------------------- Subevent: Change GoDot Palette

se_pset	lda gr_picked	; get new color value
	bmi ep4		; invalid, finished

	jsr setundo	; save current palette
	sec
	lda sc_merk+1	; get current mousepointer column
	and #$fe		; make even
	sta sc_merk+1
	sbc sc_sp		; subtract gadget position (column)
	lsr		; divide by 2
	tax		; take as an index into palette

	lda sc_merk+1	; current column pointed to (but made even)
	sta sc_sp
	lda #$02		; width: 2
	sta sc_br
	lda gr_picked	; retrieve color
	sta gr_palette,x	; enlist in current palette
	jsr ep61		; set picked color to invalid
	jsr eps7		; show color in Picked gadget
eps8	dex		; .x=$ff now
	stx gr_redisp	; flag: re-render graphics
	jmp ppal		; show new palette

; --------------------------------------------------

setundo	ldx #$0f		; save current palette
su1	lda gr_palette,x
	sta palundo,x
	dex
	bpl su1
	rts

; --------------------------------------------------
; -------------------------------------------------- Event Re-Display Graphics
; --------------------------------------------------

evdisp2	lda gr_redisp	; save current re-display status
	pha
	ldx #$01		; force re-display
	stx gr_redisp
	dex		; clear STOP key
	stx sc_stop
	jsr redisplay	; re-display
	jsr dp1		; wait for keypress
	pla		; restore redisp status
	sta gr_redisp
	rts

; -------------------------------------------------- Event Display Graphics

evdisplay	jsr redisplay	; display graphics

	lda #$00
	sta sc_stop
	ldx #$80		; initialize noise (random) values
	stx oszi3+1
	stx filter
	inx
	stx wave		; activate noise

	inc turbo		; activate turbo on Ultimate64

	lda gr_howmany	; number of colors to be rendered
	sta hmzp		; store in zeropage
	lda gr_cmode	; get graphics mode
	sta cmzp		; and store to zeropage
	jsr setvecs	; initialize all vectors and values
	jsr setclip	; compute startaddress of clip

	lda dest		; destination ($2000)
	ldx dest+1
	sta dest1
	stx dest1+1
	jsr clrclip	; clear clip area and provide histograms

	lda source	; source ($4000)
	ldx source+1
	sta source1
	stx source1+1
	lda vblock	; video RAM ($0400)
	ldx vblock+1
	sta vblock1
	stx vblock1+1

	ldx gr_dither	; set vector of current dither routine
	lda routtablo,x
	sta sc_pos
	lda routtabhi,x
	sta sc_pos+1

; --------------------------------------------------

mainpix	lda sc_clipho	; height
	sta sc_ho
dhb4	lda sc_clipbr	; width
	sta sc_br

dhb1	clc
	lda #$00		; init indeces
	sta sc_merk
	sta sc_merk+1
dhb01	jsr histo		; compute histogram for 1 tile

dhb0	ldy sc_merk	; get first byte (2 4bit pixels)
	lda (source),y
	pha
	ldy cmzp		; color mode
	bne mcskip	; multi?
	lsr		; no hires, get first 4b pixel (left)
	lsr
	lsr
	lsr
mcskip	and #$0f		; isolate 4b pixel
	tax		; care for balancing (gray: contrast/brightness)
	lda gr_btab,x
	ldy sc_merk+1	; index for "Ordered" pattern
	jsr pixel		; dither, returns a bitpattern
	and bitcnt	; isolate bitmap pixel position
	ora (dest),y	; and set bm pixel
	sta (dest),y
	lsr bitcnt	; next bm pixel position

	pla		; re-get 4bit byte (right pixel)
	and #$0f		; isolate 4b pixel
	tax
	lda gr_btab,x	; balancing, .y still valid
	jsr pixel		; dither, returns a bitpattern
	and bitcnt	; isolate bm pixel
	ora (dest),y	; and set
	sta (dest),y

	inc sc_merk	; inc index into tile
	lsr bitcnt	; next pixel position
	bcc dhb0

	ror bitcnt	; 8 pixels finished, reset mask
	inc sc_merk+1	; inc index into Ordered pattern
	lda sc_merk+1
	cmp #$08		; 8 scanlines finished?
	bcc dhb01

	inc vblock	; yes, next tile:
	bne dhb21
	inc vblock+1

dhb21	clc		; add 8 to dest vector
	adc dest
	sta dest
	bcc dhb2
	inc dest+1
dhb2	clc		; add 32 to source vector
	lda #$20
	adc source
	sta source
	bcc dhb3
	inc source+1

dhb3	lda sc_stop	; STOP pressed?
	bne break		; yes, break

	dec sc_br		; decrement width value
	bne dhb1		; until zero

; --------------------------------------------------

	clc		; to tile below first:
	lda vblock1	; add 40 to video RAM
	adc #$28
	sta vblock1
	sta vblock
	lda vblock1+1
	adc #$00
	sta vblock1+1
	sta vblock+1
	clc		; add 320 to dest
	lda dest1
	adc #$40
	sta dest1
	sta dest
	lda dest1+1
	adc #$01
	sta dest1+1
	sta dest+1
	clc		; add 1280 to source
	lda source1+1
	adc #$05
	sta source1+1
	sta source+1
	lda source1
	sta source

	dec sc_ho		; dec height
	beq dhb9		; until zero

	jmp dhb4		; else loop

; --------------------------------------------------

break	sta gr_redisp	; force re-render
	sta sc_keyprs	; simulate keypressed
dhb9	jmp dp1		; end sequence (graphics off...)

; --------------------------------------------------
; -------------------------------------------------- Dither Routines
; --------------------------------------------------

pixel	jmp (sc_pos)	; entry for dither routines

; -------------------------------------------------- Compute Clip data

setclip	lda sc_clipzl	; row of clip
	beq scp1		; zero?

	sta sc_zl		; no, increment video RAM by 40
scp4	clc
	lda vblock
	adc #$28
	sta vblock
	bcc scp2
	inc vblock+1
scp2	clc		; increment dest by 320
	lda dest
	adc #$40
	sta dest
	lda dest+1
	adc #$01
	sta dest+1
	clc		; increment source by 1280
	lda source+1
	adc #$05
	sta source+1
	dec sc_zl		; as many times as vertically indented
	bne scp4

scp1	lda sc_clipsp	; column of clip
	beq scp5		; zero?

	sta sc_sp
scp8	inc vblock	; no, inc video by 1
	bne scp81
	inc vblock+1
scp81	clc		; inc dest by 8
	lda dest
	adc #$08
	sta dest
	bcc scp6
	inc dest+1
scp6	clc		; inc source by 32
	lda source
	adc #$20
	sta source
	bcc scp7
	inc source+1
scp7	dec sc_sp		; as many times as horizontally indented
	bne scp8

scp5	rts

; -------------------------------------------------- Dith type: No Dither

dithoff	tax		; regard quantization table
	lda gr_qtab,x
	tax		; get appropriate pixel pattern ($0 or $f)
	lda htab,x
	rts

; -------------------------------------------------- Dith type: Ordered

dithhab	sta zp1
	tax		; regard quantized colors
	lda rtab,x
	ora offs,y	; compute offset into pattern
	tax
	lda gr_orderedpat,x	; get pixel pattern
	jmp dh1		; regard graphics mode

; -------------------------------------------------- Dith type: Pattern

dithpat	sta zp1
	sty hold		; save .y (pattern index)
	tax
	lda rtab,x	; regard quantized colors
	asl		; times 8
	asl
	asl
	ora hold		; regard index
	tax
	lda gr_pattern,x	; get pixel pattern

dh1	ldx cmzp		; grahics mode?
	beq dp0
	and #$0f		; if multi:
	tax		; get appropriate pixel pattern
	lda mcpat,x
dp0	ldx zp1		; get original value
	and bitcnt	; isolate bm pixel
	beq bgr		; not set?
	bne fgr		; set?

; -------------------------------------------------- Dith type: Random

dithrnd	tax
	lda rtab,x	; regard quantized colors
	beq bgr
	cmp #8		; threshold: 8
	bcs fgr

	lda rtab+1,x	; regard neighboring color
	beq dr0
	cmp #8
	bcc bgr

dr0	jsr getrnd	; get random value
rold	lda zp1
	and #1
	beq bgr		; even?
	bne fgr		; odd?

; -------------------------------------------------- Dith type: Noise

dithnoi	tax
	lda rtab,x	; regard quantized colors
	beq bgr
	sta hold		; no threshold
	jsr getrnd	; get random value
nold	lda hold
	cmp zp1		; bigger?
	bcs fgr

; --------------------------------------------------

bgr	lda htab0,x	; pixel not set, get pixel pattern
	rts

fgr	lda htab,x	; pixel set, get pixel pattern
	rts

; -------------------------------------------------- Get Random Value

getrnd	lda cmzp		; graphics mode?
	beq gr00
	lda bitcnt	; multi, isolate right pixels
	and #$55
	bne gr01
gr00	lda rausch	; hires, get random value
	and #15		; delimit to 15
	sta zp1
gr01	rts

; --------------------------------------------------
; -------------------------------------------------- Clip Routines
; --------------------------------------------------


; -------------------------------------------------- Get start values

setvecs	lda #$00
	sta sc_keyprs	; clear keyboard
	sta gr_redisp	; clear re-render flag
	sta vblock	; low bytes all $00
	sta source
	sta dest
	lda sc_clipped	; any clip set?
	bne sv0		; yes, don't change values

	sta sc_clipzl	; no, values to 0,0,40,25
	sta sc_clipsp
	lda #$19
	sta sc_clipho
	lda #$28
	sta sc_clipbr

sv0	lda #$80		; init bitmask for pixel pattern
	sta bitcnt
	lsr		; source from $4000
	sta source+1
	lsr		; dest from $2000
	sta dest+1
	lda #$04		; video from $0400
	sta vblock+1
	rts

; -------------------------------------------------- Clear Clip Area

clrclip	ldx sc_clipho	; height of clip
	ldy #$00

cc2	sty sc_pos+1
	lda sc_clipbr	; width of clip times 8
	asl
	asl
	asl
	bcc cc3
	inc sc_pos+1
cc3	sta sc_pos

	lda dest		; save dest
	pha
	lda dest+1
	pha

cc0	tya		; .y=0
	sta (dest),y	; clear bytes (to black)
	inc dest
	bne cc1
	inc dest+1
cc1	lda sc_pos	; count width
	bne cc4
	dec sc_pos+1
cc4	dec sc_pos
	lda sc_pos	; until 0
	ora sc_pos+1
	bne cc0

	pla
	sta dest+1
	pla
	clc		; add 320 to dest
	adc #$40
	sta dest
	lda dest+1
	adc #$01
	sta dest+1
	dex		; decrement height
	bne cc2

	lda dest1		; restore dest
	ldx dest1+1
	sta dest
	stx dest+1

; --------------------------------------------------

	lda gr_dither	; any dither?
	beq hist0		; no, compute histograms

	lda hmzp		; yes, get number of colors/grays
	cmp #$02		; b&w?
	bne makeetab	; no, create etab and compute histograms

; --------------------------------------------------

	lda cmzp		; yes, b&w, graphics mode?
	beq mcb
	lda #$55		; multi, get pattern $55
	!by $2c
mcb	lda #$ff		; hires, pattern $ff
	ldy #$0f

hm2l	sta htab,y	; put to table of pixel patterns
	eor #$ff
	sta htab0,y
	eor #$ff
	tax
	tya
	sta rtab,y	; put to table of quantized colors
	txa
	dey
	bpl hm2l

	lda gr_palette+1	; get neighboring color
	asl		; shift to upper nibble
	asl
	asl
	asl
	ora gr_palette	; or with color
	sta pbuf		; store value (faster rendering now)
	rts

; --------------------------------------------------

makeetab	ldy #$01
	ldx #$00
etl	lda gr_qtab,y	; compare neighboring values in quantization table
	cmp gr_qtab-1,y
	beq ets		; if equal, ignore
	tya
	sta etab,x	; if not, set position of change to etab
	inx
ets	iny
	cpy #$10
	bne etl

; -------------------------------------------------- Make Histograms

hist0	ldx #$2f		; clear histograms
	stx col00+4
	jsr clh1

	sta src		; start from $4000
	lda #$40
	sta src+1
	lda cmzp		; get graphics mode
	beq hi01
	lda #$aa		; is multi: change bits
hi01	sta bits+2
	beq hready	; finished when hires

	lda sc_clipped	; any clip?
	beq hloop		; no, proceed

	ldy hmzp		; yes, number of colors/grays
	dey
cll1	lda gr_palette,y	; background color part of palette?
	cmp backgr
	beq cls1		; yes, store index
	dey
	bpl cll1
	ldy #$20		; no, set flag
cls1	sty bktmp
hready	rts		; no histograms when clipped

; -------------------------------------------------- Histograms for Multi Mode

hloop	jsr clrhist1	; clear histogram1

	ldy #$1f		; retrieve colors
l1	lda (src),y
	and #$0f
	tax
	lda gr_btab,x	; regard balancing and quantization
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
	dey
	bpl l1

	ldy #$00		; how many colors per tile?
	ldx hmzp
	dex
	sty col00
l2	lda hist1,x
	beq s11
	iny
s11	dex
	bpl l2
	cpy #$04		; less than 4?
	bcc s2		; yes, proceed

	ldx hmzp		; no, count colors in these particular tiles
	dex
l3	lda hist1,x
	beq s3
	clc
	adc hist,x
	sta hist,x
	bcc s3
	inc hist+16,x
s3	dex
	bpl l3

s2	lda src		; next tile
	clc
	adc #$20
	sta src
	bcc hloop
	inc src+1
s4 	lda src+1
	cmp #$bd		; end of 4bit?
	bne hloop

; --------------------------------------------------

	lda #$00		; yes, retrieve most frequent color
	sta max
	sta max+1
	ldx hmzp
	dex
l4	lda hist+16,x
	tay
	cmp max+1
	bcc s5
	beq s51
	lda hist,x
	bcs s52
s51	lda hist,x
	cmp max
	bcc s5
	beq s5
s52	sta max
	sty max+1
	stx col00		; contains most frequent color
s5	dex
	bpl l4

	lda col00		; result becomes background color
	tax
	lda gr_palette,x
	stx bktmp
	sta backgr
	rts

; --------------------------------------------------

clrhist1	ldx hmzp
	dex
clh1	lda #$00
l5	sta hist1,x
	dex
	bpl l5
	rts

; -------------------------------------------------- Decide which colors per tile

histo	lda gr_dither	; any dither?
	beq dohist	; no, histogram

	lda hmzp		; b&w?
	cmp #2
	bne dohist	; no, histogram

	lda pbuf		; yes, get precomputed colors
	ldy #0
	sta (vblock),y
	rts

; --------------------------------------------------

dohist	jsr clrhist1	; clear histogram
;
	ldy #$20		; preset values (impossible value 32)
	sty col00+3
	sty col00+2
	sty col00+1
	dey

l6	lda (source),y	; count colors
	pha
	and #$0f
	tax
	lda gr_btab,x
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
	pla
	ldx cmzp
	bne s6
	lsr
	lsr
	lsr
	lsr
	tax
	lda gr_btab,x
	tax
	lda gr_qtab,x
	tax
	inc hist1,x
s6	dey		; within 64 pixels
	bpl l6

	ldy cmzp		; graphics mode
	beq s7

	ldx bktmp		; is multi:
	stx col00
	lda #$00		; don't regard background color
	sta hist1,x
	sta nr0
s7	ldx #$03
l7	ldy #$00
	sty max
	lda bits,x
	sta nr0,x
l8	lda hist1,y
	beq s8
	cmp max
	bcc s8
	sta max
	sty col00,x	; get 3 most frequent colors
s8	iny
	cpy hmzp
	bne l8
	ldy col00,x	; don't regard processed colors
	lda #$00
	sta hist1,y
	dex
	bne l7

; -------------------------------------------------- Set Colors

	ldy #$00
	lda cmzp		; graphics mode
	beq mc1

	lda col00+1	; is multi: get video RAM colors
	and #$0f
	tax
	lda gr_palette,x
	asl
	asl
	asl
	asl
	sta cols
	lda col00+2
	and #$0f
	tax
	lda gr_palette,x
	ora cols
	sta (vblock),y	; and set

	lda vblock+1	; color 3 to color RAM
	pha
	clc
	adc #$d4
	sta vblock+1
	lda col00+3
	and #$0f
	tax
	lda gr_palette,x
	sta (vblock),y
	pla
	sta vblock+1
	bne mc2		; unconditional branch

mc1	ldx col00+2	; is hires: get video RAM colors
	cpx #$20		; only 1 color in tile?
	bne ms1
	ldx col00+3	; yes, get neighboring color for background
	inx
	cpx hmzp
	bne ms2
	dex
	dex
ms2	stx col00+2

ms1	lda col00+3	; sort colors (when hires)
	cmp col00+2
	bpl nosort
	ldx col00+2
	sta col00+2
	stx col00+3
	txa
nosort	and #$0f
	tax
	lda gr_palette,x
	asl
	asl
	asl
	asl
	sta cols
	lda col00+2
	and #$0f
	tax
	lda gr_palette,x
	ora cols
	sta (vblock),y	; and set
	jmp makehtab	; make pattern table
;
mc2	ldx #$00		; sort colors (when multi)
lx	stx xbuf
	ldy #$03
ly	lda col00,x
	cmp col00,y
	bcc s9
	beq s9
	pha
	lda col00,y
	sta col00,x
	pla
	sta col00,y
	lda nr0,x
	pha
	lda nr0,y
	sta nr0,x
	pla
	sta nr0,y
s9	dey
	cpy xbuf
	bne ly
	inx
	cpx #$03
	bne lx

; -------------------------------------------------- Create Pixelpattern Table

makehtab	lda gr_dither	; any dither?
	bne makertab	; yes, branch

	ldy #$ff
	sty max
	lda cmzp		; graphics mode
	bne l9
	ldy #$01		; is hires (.y=2)
l9	iny		; is multi (.y=0)
	lda col00,y	; compute average of 2 neighboring colors
	clc
	adc col00+1,y
	lsr
	cmp #$10
	bcc s10
	lda #$0f
s10	sta max+1
	lda nr0,y
	ldx max
l10	inx
	sta htab,x	; fill table
	cpx max+1
	bcc l10
	cpx #$0f
	bcs l12
	stx max
	cpy #$03
	bne l9
l12	rts

; -------------------------------------------------- Create transition patterns

makertab	ldx #$00
	lda cmzp		; graphics mode
	bne mkt0
	ldx #$02		; is hires (.x=2)
mkt0	ldy #$00		; is multi (.x=0)
mkt1	lda gr_qtab,y
	cmp col00+1,x
	bcs mkt2
	lda nr0+1,x
	sta htab,y
	lda nr0,x
	sta htab0,y
	iny
	cpy #$10
	bne mkt1
	beq mrt0
mkt2	inx
	cpx #$04
	bne mkt1
;
mrt0	ldy #$0f
	lda #$00
irl	sta rtab,y	; set pattern (transition between two neighboring colors)
	dey
	bpl irl
;
	ldx #$00
	lda cmzp
	bne rtl0
	ldx #2
rtl0	lda col00,x
	cmp #$20
	bcs rts0
	tay
	lda etab,y
	sta rstart
	lda col00+1,x
	cmp #$20
	bcs rts0
	tay
	dey
	lda etab,y
	sta rend
	sec
	sbc rstart
	beq rts1
	tay
	lda rdtab,y
	sta rstep
	ldy rstart
	lda #$00
rtl1	clc
	adc rstep
	pha
	lsr
	lsr
	lsr
	lsr
	sta rtab,y
	iny
	cpy rend
	pla
	bcc rtl1
rts1	inx
	cpx #$04
	bne rtl0
rts0	rts

; -------------------------------------------------- Pixel Patterns

bits	!by $00,$55
	!by $aa,$ff
mcpat	!by $00,$03,$0c,$0f,$30,$33,$3c,$3f
	!by $c0,$c3,$cc,$cf,$f0,$f3,$fc,$ff
rdtab	!by $f0,$78,$50,$3c,$30,$28,$22
	!by $1e,$1b,$18,$16,$14,$12,$11,$10

; --------------------------------------------------
; -------------------------------------------------- Event: Toggle Clip/Full
; --------------------------------------------------


evarea	lda sc_clipped	; is clipped?
	beq area0		; no, toggle to Clip
	ldy #$07		; yes, toggle to Full
	!by $2c
area0	ldy #$03
	ldx #$04
area1	lda atype,y
	sta areatype-1,x
	dey
	dex
	bne area1
	tya
	bpl area2
	ldy #$03
area3	lda sc_lastclpzl,y	; set appropriate values
	sta sc_clipzl,y
	dey
	bpl area3
	inx
area2	stx sc_clipped	; flag: clipped
	sty gr_redisp	; force re-render
	jmp sh3		; show new status

; --------------------------------------------------

atype	!scr "ClipFull"
routtablo	!by <(dithoff),<(dithhab),<(dithpat),<(dithnoi),<(dithrnd)
routtabhi	!by >(dithoff),>(dithhab),>(dithpat),>(dithnoi),>(dithrnd)
offs	!by $00,$10,$20,$30,$00,$10,$20,$30

; --------------------------------------------------
; -------------------------------------------------- Event: Toggle Dither Type
; --------------------------------------------------

evdith	ldx gr_dither	; get current dither type
	lda sc_merk+1	; where did the mouseclick occur?
	cmp #$0d
	bcs dth0
	dex		; left: decrement downto 0
	bpl dth1
	ldx #$04		; start over at 4
	bne dth1
dth0	inx		; increment up to 4
	cpx #$05
	bcc dth1
	ldx #$00		; start over at 0
dth1	stx gr_dither	; set dither type
	lda #<(dithtype)	; show new status
	sta sc_texttab
	lda #>(dithtype)
	sta sc_texttab+1
	txa
	asl
	tay
	lda dtadr,y
	tax
	lda dtadr+1,y
	tay
	sta gr_redisp
	jmp gd_xtxtggl

; --------------------------------------------------

dtadr	!wo dtoff,dthab
	!wo dtpat,dtnoi,dtrnd
dtoff	!scr "    Off     @"
dthab	!scr "  Ordered   @"
dtpat	!scr "  Pattern   @"
dtrnd	!scr "   Random   @"
dtnoi	!scr "   Noise    @"

; -------------------------------------------------- Screenlist: Palette Requester

pallst	!by $00
	!by $04,$02,$24,$10,$91
	!wo 0
	!scr "Palette@"
	!by $0a,$03,$09,$03,$d0
	!wo se_paldis
	!scr "Display@"
pickbox	!by $06,$03,$22,$04,$60
	!wo se_ppick
pick	!by $0a,$1c,$09,$03,$20
	!wo 0
lesscols	!by 10,12,3,3,$c0
	!wo se_lessc
	!by $5b,0
morecols	!by 10,25,3,3,$c0
	!wo se_morec
	!by $5e,0
palbox	!by $0d,$03,$06,$04,$60
	!wo se_pset
	!by $11,$03,$09,$03,$dc
	!wo se_pdeft
	!scr "Default@"
	!by $11,$0c,$08,$03,$dc
	!wo se_pundo
	!scr " Undo @"
	!by $11,$14,$08,$03,$dc
	!wo se_pacc
	!scr "Accept@"
	!by $11,$1c,$09,$03,$dc
	!wo se_pcanc
	!scr "Cancel @"
	!by $c0,10,14,10
	!scr "Pick"
	!by $1e
	!scr " Set"
	!by $1f,0
	!by $80

; --------------------------------------------------
; -------------------------------------------------- Event: Balancing Requester
; --------------------------------------------------

evbal	jsr gd_savescvek	; save vector to main list
	ldx #<(balreq)	; show balancing requester
	ldy #>(balreq)
	jsr gd_screen
	jsr gbtab		; save balancing table for Cancel
	lda gr_brt	; save brightness and contrast values
	sta brttmp
	lda gr_ctr
	sta crttmp
	jsr brt0
	jmp gd_eloop	; wait for further events

; -------------------------------------------------- Select Gadget Brightness or Contrast

gbset	ldx #$00
	stx sc_loop
	and #$01		; determine whether even or odd
	bne ic0		; thus selecting the appropriate value display
	ldx #<(brtbox)
	ldy #>(brtbox)
	bne bgettab
ic0	ldx #<(ctrbox)
	ldy #>(ctrbox)
bgettab	stx sc_screentab
	sty sc_screentab+1
bgt1	lda #$00
	tax
	tay
bgt0	jsr gd_setpos	; get 4 parameters
	cpx #$04
	bne bgt0
	jsr gd_trim	; point to within in the display box
	jmp gd_initmove	; compute screen address

; -------------------------------------------------- Subevent: Increment Brightness

se_incbrt	lda #$00		; even function numbers: brightness
	!by $2c

; -------------------------------------------------- Subevent: Decrement Brightness

se_decbrt	lda #$02
	!by $2c

; -------------------------------------------------- Subevent: Increment Contrast

se_incctr	lda #$01		; odd function numbers: contrast
	!by $2c

; -------------------------------------------------- Subevent: Decrement Contrast

se_decctr	lda #$03
	pha
	jsr gbset		; compute screen address
	pla
	tay
	and #$01		; address the appropriate value
	tax
	lda brttmp,x
	cpy #$02		; determine function: inc or dec
	bcc ic2

	tay		; dec: is zero? (minimum)
	beq show		; yes, no more changes
	dec brttmp,x	; no, decrease
	tya
	bne show		; unconditional branch

ic2	tay		; inc: is 31? (maximum)
	cpy #$1f
	bcs show		; yes, no more changes
	inc brttmp,x	; no, increase

show	lda brttmp,x	; get value
	ldy #$20		; sign (positive)
	cmp #$10		; is at least 16? (median; shows as 0)
	bmi nega		; no, lower (show as negative values)

; --------------------------------------------------

posi	sbc #$10		; yes, subtract 16
sh0	sty sc_movetab
	jsr gd_xcnvdez	; convert value to digits
	sta sc_movetab+2	; ones' digit
	txa		; tens' digit
	and #$0f		; is zero?
	bne sh1
	ldx #$20		; yes, replace by space
sh1	stx sc_movetab+1
	lda #$03		; show 3 chars on screen
	sta sc_br
	ldx #$01
	jsr gd_fi1
	jsr makebtab	; re-compute balancing table

	ldy #$0f		; convert balancing values to dither patterns
sh2	lda gr_btab,y
	ora #$e0
	sta tpatbox,y	; write to output buffer
	dey
	bpl sh2
	ldx #<(patbox)	; compute address of patternbox on screen
	ldy #>(patbox)
	jsr bgettab
sh3	ldy #$06		; show pattern
	jmp gd_xtxout1

; --------------------------------------------------

nega	sta sc_merk	; subtract value from 16
	lda #$10
	sec
	sbc sc_merk
	ldy #$2d		; sign (negative)
	bne sh0		; unconditional branch

; -------------------------------------------------- Subevent: Reset Balancing Table

se_balrst	lda #$10		; set median value
	sta brttmp
	sta crttmp
brt0	lda #$00		; flag: first pass
brt1	pha
	pha
	jsr gbset		; reset visible values
	pla
	tax
	jsr show
	pla
	bne brt2		; finish if second pass
	lda #$01		; flag: second pass
	bne brt1		; unconditional branch
brt2	clc
	rts

; -------------------------------------------------- Subevent: Accept Balancing Values

se_balok	lda brttmp	; finalize values
	sta gr_brt
	lda crttmp
	sta gr_ctr
	lda #$01		; force re-render
	sta gr_redisp
	bne bq0		; leave requester

; -------------------------------------------------- Subevent: Cancel Changes

se_balq	ldy #$0f		; restore original values
bq1	lda btabold,y
	sta gr_btab,y
	dey
	bpl bq1
bq0	sec		; leave requester
	rts

; -------------------------------------------------- Save Balancing Table

gbtab	ldy #$0f
gbt0	lda gr_btab,y
	sta btabold,y
	dey
	bpl gbt0
	rts

; -------------------------------------------------- Compute Balancing Table

makebtab	lda crttmp	; contrast
	asl
	tax
	lda ctrtab,x
	sta ls_temp
	sta sc_pos
	inx
	lda ctrtab,x
	sta ls_temp+1
	sta sc_pos+1
	lda #$00
	sta sc_loop
	asl sc_pos
	rol sc_pos+1
	asl sc_pos
	rol sc_pos+1
	asl sc_pos
	rol sc_pos+1
	lda sc_pos	; value times 8
	sta sc_texttab
	lda sc_pos+1
	sta sc_texttab+1
	asl sc_pos
	rol sc_pos+1
	lda sc_pos	; value times 24
	adc sc_texttab
	sta sc_pos
	lda sc_pos+1
	adc sc_texttab+1
	sta sc_pos+1
	bcc mbskip
	inc sc_loop

mbskip	ldx #$00		; create 48 entry table
mbloop	lda sc_pos
	sec
	sbc ls_temp
	sta sc_pos
	lda sc_pos+1
	sbc ls_temp+1
	sta sc_pos+1
	lda sc_loop
	sbc #$00
	sta sc_loop
	lda #$07
	sec
	sbc sc_pos+1
	bcc mb0
	pha
	lda #$00
	sbc sc_loop
	pla
	bcs mbskip1
mb0	lda #$00
mbskip1	sta bttab,x
	inx
	cpx #$18
	bne mbloop

mbloop1	lda sc_pos
	clc
	adc ls_temp
	sta sc_pos
	lda sc_pos+1
	adc ls_temp+1
	sta sc_pos+1
	pha
	lda sc_loop
	adc #$00
	sta sc_loop
	pla
	clc
	adc #$07
	bcs mbf
	cmp #$10
	bcc mbskip2
mbf	lda #$0f
mbskip2	sta bttab,x
	inx
	cpx #$30
	bne mbloop1

	ldx brttmp	; brightness
	ldy #$00
mbloop2	lda bttab,x
	sta gr_btab,y
	inx
	iny
	cpy #$10
	bne mbloop2
	rts

; --------------------------------------------------

bktmp	!by 0
pdis	!by 0
ctrtab	!by $26,$00,$30,$00,$48,$00,$60,$00
	!by $90,$00,$98,$00,$93,$00,$a4,$00
	!by $ab,$00,$b2,$00,$ba,$00,$c3,$00
	!by $cd,$00,$d8,$00,$dc,$00,$f1,$00
	!by $00,$01,$25,$01,$2c,$01,$3b,$01
	!by $55,$01,$74,$01,$9a,$01,$c7,$01
	!by $00,$02,$49,$02,$ab,$02,$33,$03
	!by $00,$04,$55,$05,$74,$06,$00,$08

; -------------------------------------------------- Screenlist for Balancing Requester

balreq	!by $00
	!by $06,$07,$1a,$0c
	!by $91,$00,$00
	!scr "Balancing@"
	!by $08,$08,$03,$03
	!by $c0,<(se_decbrt),>(se_decbrt)
	!scr "<@"
brtbox	!by $08,$0b,$06,$03
	!by $a0,$00,$00
	!scr "   @"
	!by $08,$11,$03,$03
	!by $c0,<(se_incbrt),>(se_incbrt)
	!scr ">@"
	!by $08,$14,$03,$03
	!by $c0,<(se_decctr),>(se_decctr)
	!scr "<@"
ctrbox	!by $08,$17,$06,$03
	!by $a0,$00,$00
	!scr "   @"
	!by $08,$1d,$03,$03
	!by $c0,<(se_incctr),>(se_incctr)
	!scr ">@"
patbox	!by $0c,$0b,$12,$03
	!by $a0,$00,$00
tpatbox	!by $e0,$e1,$e2,$e3,$e4,$e5,$e6,$e7
	!by $e8,$e9,$ea,$eb,$ec,$ed,$ee,$ef,$00
	!by $0f,$08,$08,$03
	!by $dc,<(se_balrst),>(se_balrst)
	!scr "Reset@"
	!by $0f,$10,$08,$03
	!by $dc,<(se_balok),>(se_balok)
	!scr "Accept@"
	!by $0f,$18,$08,$03
	!by $dc,<(se_balq),>(se_balq)
	!scr "Cancel@"
	!by $c0,$0a,$08,$0a
	!scr "Brightness@"
	!by $c0,$0a,$15,$08
	!scr "Contrast@"
	!by $80

; --------------------------------------------------
; -------------------------------------------------- Event: Display Preview
; --------------------------------------------------
;
; When entering this event routine you have just clicked the
; appropriate gadget. So, all values are still set here and now.
; The event routine first reverts the gadget's background.
;

evprviu	jsr gd_initmove	; compute screen address
	pha		; A-reg contains sc_vekt20+1
	lda sc_vekt20
	pha
	jsr gd_invert	; reverting to black

	ldx #$c0		; make space for three sprites...
	ldy #$00
loop1	lda spr2-1,x
	sta dbuf-1,x
	tya
	sta spr2-1,x	; and initialize to $00
	sta spr5-1,x
	dex
	bne loop1

	sta sprpri	; priority
	sta xexp		; no expansion
	sta yexp

	lda #$fc		; sprites 2 to 7: multi mode
	sta sprmulti

	ldx #$05		; colorize: mid gray
	lda #$0c
loop3	sta sprcol1,x
	dex
	bpl loop3
	lda #$0b		; dark gray
	sta sprcol2
	lda #$0f		; light gray
	sta sprcol3

	ldx #$0b		; define positions (in gadget)
loop4	lda xytab,x
	sta sprxy,x
	dex
	bpl loop4
	lda xmsb		; beyond 255
	ora #$fc
	sta xmsb

	ldx #$05		; activate sprite pointers
	ldy #$ff
ploop	tya
	sta sprptr,x
	dey
	dex
	bpl ploop

	stx sprreg	; .x=$ff: switch sprites on
;
; Now rendering the 4Bit Area to the sprites. Will be done as three
; bands of 12 tiles down from left to right.
;
	ldx #$02		; three times 12 tiles (20 rows down)
m0loop	txa
	pha
	lda srcl,x	; set source address (4Bit)
	sta sc_pos
	lda srch,x
	sta sc_pos+1
	lda dstl,x	; set destination address (sprites)
	sta sc_loop
	lda dsth,x
	sta sc_loop+1
	lda #$00		; counter to skip byte 63 in sprite
	sta sc_screentab
	jsr makeit	; render one band
	pla
	tax
	dex
	bpl m0loop	; and the next two
;
; now rendered, wait for click to shut down sprites
;
	inx		; wait for click
	stx sc_keyprs
wait	lda sc_keyprs
	beq wait
;
	lda #3		; only sprites 0+1 remain (mouse)
	sta sprreg
	lda xmsb		; force to lower 256 position
	and #$03		; (sometimes flickers, can't imagine why)
	sta xmsb

	pla		; restore gadget address
	sta sc_vekt20
	pla
	sta sc_vekt20+1
	jsr gd_invert	; revert to blue again

	ldx #$c0		; restore rendered image from buffer
piu0	lda dbuf-1,x
	sta spr2-1,x
	dex
	bne piu0

	clc		; don't leave screenlist
	rts
;------------------------------------------------------------------
;
; rendering 4Bit Area to 6 sprites
;
;------------------------------------------------------------------
makeit	ldx #$00		; MUST be $00!
	ldy #$14		; 20 rows of tiles down

prloop	tya		; start preview loop
	pha
	lda #$40		; flag: %0100 0000, 2 passes per tile
	sta lflag

dzloop	lda #$03		; flag: 3 passes across
	sta brttmp

zloop	ldy #$60		; 4 tiles from right to left
	lda lflag		; on 2nd pass (tile):
	bpl bloop
	ldy #$70		; indent to 4 pixels below

bloop	lda (sc_pos),y	; get 4bit data
	lsr
	lsr
	lsr
	ror crttmp
	lsr
	ror crttmp

	tya		; next tile (to the left)
	sec
	sbc #$20
	tay
	bpl bloop

	lda crttmp	; byte complete, write to sprites
	sta (sc_loop,x)

skip64	inc sc_loop	; increment destination pointer
	bne s1
	inc sc_loop+1

s1	inc sc_screentab	; skip byte 63
	lda sc_screentab
	cmp #$3f
	beq skip64

	lda sc_pos	; add to 4 tiles ahead
	clc		; (summing up to 12 tiles at last)
	adc #$80
	sta sc_pos
	bcc skip
	inc sc_pos+1

skip	ror brttmp	; loop for next two passes across
	bcs zloop

	lda sc_pos	; 3 times 4 tiles backwards
	sec
	sbc #$80
	sta sc_pos
	lda sc_pos+1
	sbc #$01
	sta sc_pos+1

	rol lflag		; loop for second pass within tile
	bcc dzloop

	lda sc_pos+1	; add $500 (1280): next row of tiles
	adc #$04
	sta sc_pos+1

	pla		; count 20 times
	tay
	dey
	bpl prloop
	rts		; until finished

;-------------------------------------------------------------

shiftprs	sei
	lda #$fd		; col %11111101
	sta $dc00
	lda $dc01		; row %10000000
	and #$80		; if .z: shift pressed
	cli
	rts

;-------------------------------------------------------------
; Data (screen positions and so on)
;-------------------------------------------------------------

srcl	!by $40,$c0,$40	; not from leftmost position!
srch	!by $4d,$4b,$4a

dstl	!by $80,$00,$80	; sprite block addresses
dsth	!by $3f,$3f,$3e

xytab	!by $07,$91,$07,$a6
	!by $1f,$91,$1f,$a6
	!by $37,$91,$37,$a6
	!by $00

; --------------------------------------------------
; -------------------------------------------------- Event: GoDot Guru
; --------------------------------------------------

evinfo	jsr gd_sproff	; pointer off

	lda #$05		; scroll screen 5 rows down
	sta sc_screentab
scrloop	jsr home		; be sure to be at home position
	ldx #$00
	jsr scroll	; scroll screen down
	dec sc_screentab
	bne scrloop

	lda border	; save current main color
	sta crttmp
	lda charreg	; save $d018
	sta sc_screentab+1

	lda #$00		; clear keyboard
	sta ls_temp
	sta sy_tbuffer
	jsr set		; activate raster irq
	jsr text		; show Guru text ("GoDot Creation Nr...")
tastean	lda sy_tbuffer	; wait for key
	bne ok		; key pressed, finish
	jsr blink		; otherwise: blink box
	lda jf2		; fire on joystick?
	and #$10
	bne tastean	; no, wait

ok	jsr off		; de-activate Guru
	jsr gd_spron	; pointer on
	sec		; leave to main screen
	rts

; -------------------------------------------------- Guru IRQ

set	sei
	lda irq
	sta oldirq
	lda irq+1
	sta oldirq+1
	lda #<(newirq)
	sta irq
	lda #>(newirq)
	sta irq+1
	lda #$00
	sta raster
	lda raster-1
	and #$7f
	sta raster-1
	lda #$81
	sta rirqen
	lda #$80
	sta ciactrla
	cli
	rts

; -------------------------------------------------- New IRQ

newirq	sei
	lda reqirq
	sta reqirq
	bmi rasterirq
	lda ciairq
	cli
	jmp gd_endirq

; -------------------------------------------------- Guru Activity

rasterirq	sei
	lda raster
	bne gskip
	lda #$00		; black screen (above raster split)
	sta border
	sta backgr
	lda #$17		; standard charset
	sta charreg
	lda #$54
	sta raster
	lda raster-1
	and #$7f
	sta raster-1
	cli
	jmp (oldirq)

; --------------------------------------------------

gskip	ldx #$09
irqwait	nop
	dex
	bne irqwait
	lda crttmp	; blue screen (below raster split)
	sta border
	sta backgr
	lda sc_screentab+1	; GoDot charset
	sta charreg
	lda #$00
	sta raster
	lda raster-1
	and #$7f
	sta raster-1
	cli
	jmp gd_endirq

; -------------------------------------------------- End Guru

off	sei
	lda #$93		; clear screen (and home)
	jsr bsout
	lda #$00		; reset all values
	sta rirqen
	lda oldirq
	sta irq
	lda oldirq+1
	sta irq+1
	lda #$01
	sta ciactrla
	lda crttmp
	sta border
	sta backgr
	lda sc_screentab+1
	sta charreg
	cli
	rts
;
; -------------------------------------------------- Create Guru Information Message
;
text	ldx #2
	ldy #3
tx03	lda sy_version-1,x	; create version number digits
	pha
	and #15
	ora #$30
	sta vermain,y
	pla
	lsr
	lsr
	lsr
	lsr
	ora #$30
	dey
	sta vermain,y
	dey
	dex
	bne tx03

	iny
tx02	lda created,y	; create version number string
	cmp #$2e
	beq tx00
	sta versn,x
	inx
tx00	iny
	cpx #$03
	bne tx01
	inx
tx01	cpx #$0a
	bne tx02

	lda #<(gurubox)	; write box border
	sta ls_temp+1
	lda #>(gurubox)
	sta brttmp
	ldx #$00
	stx sc_zl
	stx sc_sp
	stx sc_loop
	ldx #$04
	stx sc_ho
	ldx #$28
	stx sc_br

	lda #$4c		; JMP
	sta patch1
	jsr gd_initmove
	jsr gbox
	lda #$20		; JSR
	sta patch1

	ldy #$00		; write text (light red: $0a)
	ldx #$0a
	stx sc_chgcol
txloop	lda line1,y
	sta scr1,y
	txa
	sta scr1+$d400,y
	iny
	cpy breit1
	bne txloop
	ldy #$00
txloop2	lda line2,y
	sta scr2,y
	txa
	sta scr2+$d400,y
	iny
	cpy breit2
	bne txloop2
	rts		; finished

; -------------------------------------------------- Box data

gurubox	!by $7d,$40,$6d,$5d,$20,$5d,$6e,$40
	!by $70
line1	!scr "A.Dettke & W.Kling"
line2	!scr "GoDot Creation No. "
vermain	!scr "00000"
versn	!scr "000.00000000"

; -------------------------------------------------- Blink Box Border

blink	ldy #$28
	lda sc_chgcol	; write color
bl0	sta cram,y
	sta cram+119,y
	dey
	bpl bl0
	sta cram+79
	sta cram+80
	ldx #$fa		; wait a bit
	jsr gd_dl2
	lda ls_temp	; toggle flag
	eor #$01
	sta ls_temp
	bne bl1
	lda #$0a		; blink between light red...
	!by $2c
bl1	lda #$00		; and black (background color)
	sta sc_chgcol
	rts

; --------------------------------------------------

modend	!eof		; end of upmem routines
